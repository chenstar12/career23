- 反射是框架的灵魂 ---- 获取类的任意属性和方法 + 调用这些方法；

## 反射的应用场景？

Spring/Spring Boot、MyBatis 等框架，大量使用了反射机制、**动态代理**（动态代理也依赖反射）

动态代理示例，用反射类 `Method` 调用指定方法:

```java
public class DebugInvocationHandler implements InvocationHandler {
    private final Object target; // 代理类中的真实对象
    public Object invoke(Object proxy, Method method, Object[] args) {
        System.out.println("before method " + method.getName());
        Object result = method.invoke(target, args);
        System.out.println("after method " + method.getName());
        return result;
```

Java **注解** 的实现也用反射: 基于反射分析类，然后获取到类/属性/方法/方法的参数上的注解；

- Spring 的 `@Component`注解声明了类为 Spring Bean； `@Value`注解读取配置文件中的值；

## 反射机制的优缺点

**优点** ： 让代码更灵活、让各种框架提供开箱即用的功能；

**缺点** ：运行时有了操纵类的能力，增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）；反射的性能稍差，但对于框架的实际影响不大；

## 反射实战

### 获取 Class 对象的四种方式

```java
Class alunbarClass = TargetObject.class; // 类名已知
```

```java
Class alunbarClass1 = Class.forName("cn.javaguide.TargetObject"); // 不知道类名：Class.forName()传入类的全路径获取
```

```java
TargetObject o = new TargetObject();
Class alunbarClass2 = o.getClass(); // 对象实例.getClass()
```

```java
ClassLoader.getSystemClassLoader().loadClass("cn.javaguide.TargetObject"); // 类加载器.loadClass()传入类路径
```

### 反射的一些基本操作

1. 创建要用反射操作的类 `TargetObject`。

```java
package cn.javaguide;

public class TargetObject {
    private String value;

    public TargetObject() {
        value = "JavaGuide";
    }

    public void publicMethod(String s) {
        System.out.println("I love " + s);
    }

    private void privateMethod() {
        System.out.println("value is " + value);
    }
}
```

2. 使用反射操纵类的方法、参数

```java
package cn.javaguide;

import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

public class Main {
    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException, NoSuchFieldException {
        /**
         * 获取 TargetObject 类的 Class 对象并且创建 TargetObject 类实例
         */
        Class<?> tagetClass = Class.forName("cn.javaguide.TargetObject");
        TargetObject targetObject = (TargetObject) tagetClass.newInstance();
        /**
         * 获取 TargetObject 类中定义的所有方法
         */
        Method[] methods = targetClass.getDeclaredMethods();
        for (Method method : methods) {
            System.out.println(method.getName());
        }

        /**
         * 获取指定方法并调用
         */
        Method publicMethod = targetClass.getDeclaredMethod("publicMethod",
                String.class);

        publicMethod.invoke(targetObject, "JavaGuide");

        /**
         * 获取指定参数并对参数进行修改
         */
        Field field = targetClass.getDeclaredField("value");
        //为了对类中的参数进行修改我们取消安全检查
        field.setAccessible(true);
        field.set(targetObject, "JavaGuide");

        /**
         * 调用 private 方法
         */
        Method privateMethod = targetClass.getDeclaredMethod("privateMethod");
        //为了调用private方法我们取消安全检查
        privateMethod.setAccessible(true);
        privateMethod.invoke(targetObject);
    }
}

```

输出：

```
publicMethod
privateMethod
I love JavaGuide
value is JavaGuide
```

**注意** : 上面代码运行的 `ClassNotFoundException` 异常, 原因是你没有下面代码的包名替换

```java
Class<?> targetClass = Class.forName("cn.javaguide.TargetObject");
```

