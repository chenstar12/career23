---
layout: post
title:  "计算机发展史-Computer History"
date:   2010-07-26 23:42:00
categories: 计算机基础
tags: 高德纳 图灵 冯·诺依曼 陈皓 少儿编程 网络 体系结构 CPU arm x86 OSI 编程语言 编码
excerpt: 计算机发展历史，编程语言诞生过程，及几位关键人物
mathjax: true
permalink: /computer
---

* content
{:toc}

# 总结

- 【2022-2-28】MIT出品的The Missing Semester of Your CS Education的[中文翻译地址](http://missing-semester-cn.github.io/),讲授shell命令行、强大的文本编辑器vim的使用、使用版本控制系统git提供的多种特性, 调试性能分析，元编程，密码学，大杂烩等等。
- 【2021-6-16】[你管这玩意儿叫CPU？](https://www.toutiao.com/i6974241663241683463/). 过去200年人类最重要的发明是什么？蒸汽机？电灯？火箭？这些可能都不是，最重要的是晶体管,无论程序员编写的程序多么复杂，软件承载的功能最终都是通过这个小东西简单的开闭完成的. 组成与或非门。
- 【2021-3-31】[图灵奖今日出炉](https://mp.weixin.qq.com/s/Q6kbBomC85xbmKS2SLllfA)，“龙书” 作者、编程语言大佬 Alfred Aho 和 Jeffrey Ullman 获奖
- 【2020-10-29】源自linux之父的名言：**talk is cheap，show me the code**，汉化版：**北沙滩**（别瞎谈），**亮马桥**（亮码瞧）
- 计算机网络里的 **OSI七层模型** 或 **TCP/IP五层模型**，即应用层（应用层、表示层、会话层）、传输层、网络层、数据链路层、物理层
- ![](https://pic4.zhimg.com/50/v2-6531ff0d8cbf967211297ef7c7813ab1_hd.jpg)
- [OSI七层模型](https://www.toutiao.com/w/a1701287080764423/)
- ![](https://p5.toutiaoimg.com/img/tos-cn-i-0022/d2916c97afc94b9daa01bdaca34759a0~tplv-obj:1575:2227.image?from=post)

# 计算机编程史

[计算机编程简史](https://coolshell.cn/articles/2724.html)

- 一张经典的图揭示计算机发展历史，可以看到，其中很大一部分人都和Unix有着不解之缘
  - 参见《[Unix传奇上篇](https://coolshell.cn/articles/2322.html)，[Unix传奇下篇](https://coolshell.cn/articles/2324.html)》
 
*   [英文原版](http://www.smashingmagazine.com/2010/06/06/designing-the-world-of-programming-infographic/)
*   [中文翻译版](http://www.mazingtech.com/cn/list.aspx/News/1/%E5%9B%BE%E8%AF%B4%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A8%8B%E7%AE%80%E5%8F%B2)

计算机编程简史图（英文版）（中文版）

|英文|中文|
|---|---|
|[![](https://coolshell.cn/wp-content/uploads/2010/07/aboutprogramming04.eng_-409x1024.jpg "计算机编程简史图（英文版） ")](https://coolshell.cn/wp-content/uploads/2010/07/aboutprogramming04.eng_.jpg)|[![](https://coolshell.cn/wp-content/uploads/2010/07/aboutprogramming04_cn-409x1024.jpg "计算机编程简史图（中文版） ")](https://coolshell.cn/wp-content/uploads/2010/07/aboutprogramming04_cn.jpg)|
|||


## 计算机之父

- “计算机之父”这种笼统的称谓没有明确的结果。你可以认为是图灵，也可以认为是冯·诺依曼，你认为是谁就是谁。
- 非要叫的话可以是：
   - `巴贝奇`Charles Babbage——**通用计算机**之父
      - 巴贝奇在1834年所构思的分析机（通用计算机），就已有了计算机的五个部分：处理器、控制器、存储器、输入与输出装置，而不是到了冯·诺依曼才提出的。
      - 生活在机械时代，却构思出了完整的计算机结构，领先世界一百年。
      - [机械美学：差分机的运作](https://v.qq.com/x/page/i0164fo4om1.html)
      - <iframe frameborder="0" src="https://v.qq.com/txp/iframe/player.html?vid=d0319t31fw9" allowFullScreen="true" height="600" width="100%"></iframe>
   - `图灵`Alan Turing——**计算机科学**之父
      - 图灵在现在毫无疑问是名气最大的，有套书以他命名，还有个公司用他咬过的苹果做logo。
      - 图灵也是个天才，他的工作非常有开创性，系统建构了计算机科学的基础，提出了图灵机、图灵测试，所以被称为“计算机科学之父”。
   - `约翰·阿坦那索夫`John Vincent Atanasoff——**电子计算机**之父
      - 阿坦纳索夫和克利福德·贝瑞在1939年制造了`ABC机`。
      - 在电子时代，作为第一台电子计算机的发明者，拔得了头筹，也够资格被称为“电子计算机之父”了。
      - 那时也已经开始使用二进制了，所以二进制也不是冯·诺依曼首创的。
   - `冯·诺依曼`John von Neumann——**现代计算机**之父
      - 在科学界名声很响，有许多开创性的工作，包括数学、量子力学、计算机和经济学领域。
      - 他对二战的贡献很大，不仅参与原子弹研制，还对ENIAC作了关键改进。
      - 另外他还最终完善了计算机的模型，提出冯诺依曼机，奠定了我们现代所使用的计算机的基础。所以把冯诺依曼称为“现代计算机之父”是实至名归的。

- 参考作者：[滑稽现实主义](https://www.zhihu.com/question/27883465/answer/93161520)


## 图灵

- ![](https://pic2.zhimg.com/80/v2-acdf678e24dba6143bc5cfeea626afb0_720w.jpg)

### 成长经历

- 艾伦·麦席森·图灵（英语：Alan Mathison Turing，1912年6月23日—1954年6月7日），英国数学家、逻辑学家，被称为计算机科学之父，人工智能之父。
- 1931年图灵进入剑桥大学国王学院，毕业后到美国普林斯顿大学攻读博士学位，第二次世界大战爆发后回到剑桥，后曾协助军方破解德国的著名密码系统Enigma，帮助盟军取得了二战的胜利。
- 1952年，英国政府对图灵的同性恋取向定罪，随后图灵接受化学阉割（雌激素注射）。
- 1954年6月7日，图灵吃下含有氰化物的苹果中毒身亡，享年41岁。
- 2013年12月24日，在英国司法大臣克里斯·格雷灵的要求下，英国女王伊丽莎白二世向图灵颁发了皇家赦免。
- 图灵对于人工智能的发展有诸多贡献，提出了一种用于判定机器是否具有智能的试验方法，即图灵试验，至今，每年都有试验的比赛。此外，图灵提出的著名的图灵机模型为现代计算机的逻辑工作方式奠定了基础。

1912年6月23日，图灵出生于英国帕丁顿一个没落的贵族家庭，由于父母常年在印度工作，他和年长4岁的哥哥一起被寄养在一对军人夫妇的家中。图灵的童年十分平凡，和普通男孩一样，经历过**调皮捣蛋**和**孤僻寡言**的的阶段，他天性聪敏却有着严重**偏科**的倾向，许多教过他的老师对他的评价并不高。

10岁那年，图灵接触到一本改变了他一生的童书——《**儿童必读的自然奇迹**》，这本科普读物打开了一扇新世界的大门，图灵发现门的那边堆满了一种对他来说最有吸引力的知识——**科学**。他开始**疯狂**地寻找和自学有关科学的一切知识，并用日用品做一些简单的化学实验。他很快意识到手头的科普读物过于浅显，妨碍了他了解事物背后更深层的原理。他甚至写信给父母讨要真正的科学书籍，而不是儿童百科。他写到：“《儿童必读的自然奇迹》中说，二氧化碳在血液里变成苏打，又在肺里变回二氧化碳。如果可以，请把苏打的化学名称，最好是化学式寄给我，好让我看看这个过程到底是怎么进行的。” 13岁时，他已经对酒精等有机物的分子式和结构式了如指掌。

1926年，聪明好学而又对科学知识近乎偏执的图灵考入了舍尔伯尼中学。开学当天正赶上英国大罢工，公共交通瘫痪，图灵竟用两天时间靠自行车征服了到学校的60英里（近100公里）路程。这不是一次冲动之举，而是精心策划之下的行动，当地报纸还专门刊载了这一令人吃惊的事迹。

图灵很有才，也很有**执行力**，却在与人沟通上遇到了大麻烦。知子莫若母，图灵的母亲在为他寻找合适的中学时就一度担心他没法适应公学生活，成长为高智商、低情商的怪人。在讲究教条与制度而不重视理性和科学的舍尔伯尼，图灵显得格格不入，被多数同学孤立和欺负，连老师也经常拿他的小习惯开涮，这对一个心智尚未成熟的男孩来说非常可怕。他们的校长倒看得十分透彻，曾警告图灵的父母：“我希望他不要两头都落空。如果他要留在公学，就必须以好好接受我们的教育为目标；如果他只是想做科学家，那么呆在公学就是浪费时间。”

舍尔伯尼是当时英国社会的一个缩影，中学的经历也预示着图灵不被理解的一生。

1931～1934年，成年后的图灵在剑桥大学国王学院攻读**数学**专业。尽管这里的制度依旧古板，像个放大版的舍尔伯尼，图灵依旧孤僻，但接触到了世界顶级的数学家和一流的学术专著，他可以更专注于自己喜欢的领域，并包揽了许多数学方面的奖项。毕业后，图灵以优异的成绩成为国王学院研究员。他在希尔伯特的问题上花费了整整一年的时间，最终在1936年的《**伦敦数学协会会刊**》上发表了那篇改变世界的论文——《**论可计算数及其在判定问题中的应用**》，提出了使其成为“计算机科学之父”的图灵机。

论文正式发表之前，图灵只身前往美国普林斯顿，在那里找到了领先一步发表成果的邱奇，并师从他继续深造。1937年，图灵嗅到了纳粹德国引战的可能，开始把业余时间花在密码学的研究上。1938年，图灵在取得博士学位后返回了正在紧张备战的英国，不多久，他便参与到政府的密码破译[3]项目中，和全国各地顶尖的数学家们一起，在白金汉郡的布莱切利公馆（Bletchley Park）中深居简出，左右世界战争的格局。

二战时期，各国已经使用无线电进行作战指挥，由于信号可以轻易被敌国接收，需要对无线电内容进行加密，比如将“ABCD”改成“BCDE”发出去，当然军用的加密方式不会如此简单。当时的德国使用一种叫谜机（Enigma machine）的加密机器，按下某个字母的按键，其加密后对应的字母小灯就会亮起。内部的转轮和接插线板将这种对应关系随意打乱，每按一次按键，转轮就会转动一次，组合成新的对应关系，比如第一次按下A，D灯亮起，再按一次A，亮起的可能是Z灯，毫无规律可循。更棘手的是，德军几乎每天都会变更其中的接线。
- <img src="https://pic4.zhimg.com/80/v2-b36ef92aabab27e6ce53e2d0c66e770f_720w.jpg" width="40%" >

解密的方式是**穷举**，即遍历所有可能的对应关系，直到找出有意义的关键词，而这恰恰是机器最擅长的事。英国的同盟国波兰在战前就成功研制了破解谜机的**炸弹机**（bomba），可惜德国在1938年年底将谜机上的转轮从3个增加到了5个，解密的复杂度呈爆炸式增长，针对3转轮谜机设计的炸弹机还未在二战发挥价值就已经宣告报废。解决这个难题的关键人物正是**图灵**，新建的炸弹机（bombe）成功破解了5转轮谜机。其难度之大，大到英国首次利用破解的信息破坏德军行动时，德国的密码专家首先排除了谜机被破解的可能性。
- <img src="https://pic4.zhimg.com/80/v2-4ba1b7d04c066452bfe03492a0e4803f_720w.jpg" width="40%" >

随后，对密码学有着深刻认识的图灵还探索出一种高效的解密算法，人称图灵方法（Turingery），该算法成为布莱切利破解德国密码的核心理论。

布莱切利的工作是图灵在短暂的一生中，为人类所做的第二项伟大贡献。他的成果使战争至少提前2年结束，挽救了至少1400万人的生命。前英国首相温斯顿·丘吉尔曾表示，二战的胜利最该感谢的人就是图灵。

战后，图灵进入国家物理研究所，并设计了属于最早一批电子计算机之一自动计算机ACE（Automatic Computing Engine），首次实现了他心目中的通用图灵机。1950年3月10日，ACE的简化版Pilot ACE开始运行，完整的ACE直到图灵去世之后才建成。
- <img src="https://pic2.zhimg.com/80/v2-1b65d32fd247bf60a1d6417f7158e4a1_720w.jpg" width="70%" >

1948年，图灵成为曼彻斯特大学数学系讲师，并于次年担任学校计算机实验室的副主任，负责计算机软件的研究。他还成为计算机企业的顾问，帮助其研发商用电子计算机。1951年，英国皇家学会将图灵吸纳为会员。

这些年间，图灵的主要智慧仍留给了数学和计算机的理论研究。1950年，第二篇影响世界的论文《计算机与智能》问世，在那个电子计算机才刚刚起步的年代，高瞻远瞩的图灵用一个问题就叩开了人工智能的大门：“机器会思考吗？”文中提出了著名的`图灵测试`（Turing test）：
- 让一台机器躲在挡板后回答测试人员的提问，看测试人员能否判断自己面对的是机器还是真人。
- 能否通过图灵测试，是衡量机器智能程度的重要指标。
- 这位“人工智能之父”过于乐观地预言：到2000年，计算机应该能“骗过”30%的测试人员。

图灵机、炸弹机、人工智能……图灵献给世界太多伟大的作品，却没能在生前得到应有的名誉乃至起码的认可。人们始终觉得他是个难以亲近的怪人，对其二战时期涉密的功绩更是一无所知。

- 1952年，他因同性恋的罪名被起诉，在坐牢和化学阉割之间，他无奈选择了后者，旁人的偏见和药物的副作用使他承受着精神和肉体的双重痛苦。
- 1954年6月7日晚上，他躺在家里因氰化物中毒离开了人世，床头放着一个咬过的苹果，还有16天就是他42岁的生日。尸检的结果认定图灵是通过毒苹果自杀的，却没有对这个苹果做氢化物检测，他的母亲和哥哥却坚持认为这是一场化学实验导致的意外，而真相只有图灵自知。
- 2009年，超过3万人在线请愿为图灵平反，英国首相戈登·布朗代表政府公开道歉。2013年，英国女王伊丽莎白二世正式颁发皇家赦免，图灵终于得到了迟来的公道。
- 1966年，美国计算机协会ACM（Association for Computing Machinery）设立计算机领域的最高奖项，命名为图灵奖。图灵奖素有“计算机界的诺贝尔奖”之称，图灵的名字当之无愧。
- 2019年，英国的中央银行——英格兰银行宣布，图灵的肖像将出现在新版的50英镑纸币上，以此纪念这位改变了国家乃至整个世界命运的伟人。

[图灵机：计算机世界的理论基石](https://zhuanlan.zhihu.com/p/135251031)

### 图灵奖

- 待补充


### 图灵机历史

[图灵机：计算机世界的理论基石](https://zhuanlan.zhihu.com/p/135251031)

- 公元前4世纪，由哲学家欧布里德（Eubulides）提出的著名的**说谎者悖论**。
  - 古老而经典的逻辑游戏：如果一个人说“我正在说谎”，那么他到底在不在说谎呢？
    - 如果他不在说谎，那么“我正在说谎”这句话就是真的；
    - 如果他  在说谎，那么“我正在说谎”这句话就是假的。
  - 无论从哪个方向推演，得到的都是**自相矛盾**的结论，我们无从判定他在不在说谎。
- 类似的，还有伯特兰·罗素（Bertrand Russell）在1901年提出的**罗素悖论**，它的通俗化版本是流传更广的理发师悖论：
  - 如果一位理发师只给不为自己理发的人理发，那他给不给自己理发呢？
  - 罗素悖论直接动摇了整个数学大厦的根基——`集合论`。为使命题合理，当那位理发师圈定服务对象的范围时，必须把自己排除在外。这也就意味着，没有包罗万象的集合——至少它不能轻易包含自己。
- 这些悖论都源自“罪恶”的自指 —— <font color='red'>当一套理论开始描述自身，就难免要出现悖论。</font>
  - 即使再不情愿，人们也不得不承认数学是不完美的，至少它没有自圆其说的能力。
- 尽管如此，仍有数学家想在限定的范围内负隅顽抗，他们找到一个完备的系统，寻求能够判定命题真假的通用算法。这就是德国数学家大卫·希尔伯特（David Hilbert）和威廉·阿克曼（Wilhelm Ackermann）在1928年提出的**判定问题**（Entscheidungsproblem/decision problem）。
- 只可惜没过几年，这种可能性也被否定了。
- 1936年，两位年轻的数学家分别用不同的方法给出了判定问题的解答。
  - 一位是来自美国的阿隆佐·邱奇（Alonzo Church），他引入了一种叫**λ演算**的方法，并最终证明没有任何通用算法可以判定任意两个λ表达式是否相等；
  - 另一位就是来自英国的艾伦·图灵（Alan Turing），和枯燥的数学推理不同，他使用了一种更有趣、更形象的模型，邱奇给了它一个响亮的名字——`图灵机`（Turing machine）。

【2022-1-24】二进制原理
- ![](https://p26.toutiaoimg.com/img/tos-cn-i-qvj2lq49k0/5ba41d7c1788478d891cd6cf4b505709~tplv-obj:400:224.gif)
- ![](https://p26.toutiaoimg.com/img/tos-cn-i-qvj2lq49k0/3f1744b7623c42408114a178ff63f71d~tplv-obj:320:240.gif)


#### 图灵机介绍

图灵机是数学家阿兰·图灵1936年提出来的虚拟的机器，尽管这个机器很简单，但它可以模拟计算机的任何算法，无论这个算法有多复杂。
- ![](https://pic2.zhimg.com/80/v2-94ce773233e7ce82a440c59239f384d9_720w.jpg)
- 假设有一个无穷的纸带，纸带就像一个存储器一样。纸带上面的每个格子是空白的，但是可以读写数据，在这个例子里，机器只能写0，1，或者什么也不写。这个机器就是包含3个信号的图灵机。
- 机器有一个探头，这个头可以移动到每一个空格上，用这个头，机器可以有3个基本操作。
  - 1、 读空格的数据
  - 2、 编辑数据，可以是写一个新的数据，可以是擦除数据
  - 3、 移动纸带向左或者向右，这样机器可以读或者编辑旁边的格子
- 参考：Computer laboratory of university of Cambridge。剑桥大学计算机系：[What is a Turing machine?](https://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/turing-machine/one.html)


图灵机的基本组成如下：
- 有一条「纸带」，纸带由一个个连续的格子组成，每个格子可以写入字符，纸带就好比内存，而纸带上的格子的字符就好比内存中的数据或程序；
- 有一个「读写头」，读写头可以读取纸带上任意格子的字符，也可以把字符写入到纸带的格子；
- 读写头上有一些部件，比如存储单元、控制单元以及运算单元：
  - 1、存储单元用于存放数据；
  - 2、控制单元用于识别字符是数据还是指令，以及控制程序的流程等；
  - 3、运算单元用于执行运算指令；

作者：[小林coding](https://www.zhihu.com/question/348237008/answer/1956489945)

图灵机的样子：
- ![](https://pic2.zhimg.com/80/v2-cd2fdeef6ca619507aea9fb06408e91b_720w.jpg)


#### 图灵机工作原理

图灵的基本思想是用机器来**模拟**人们用纸笔进行数学运算的过程，而且还定义了计算机由哪些部分组成，程序又是如何执行的。

图灵机是图灵受打字机的启发而假想出来的一种抽象机器，其处理对象是一条无限长的一维纸带。纸带被划分为一个个大小相等的小方格，每个小方格可以存放一个符号（可以是数字、字母或其他符号）。有个贴近纸带的读写头，可以对单个小方格进行读取、擦除和打印操作。为了让读写头能访问到纸带上的所有小方格，可以
- （1）固定纸带，让读写头沿着纸带左右移动，每次移动一格
- （2）固定读写头，让纸带左右移动

后一种方式类似当时穿孔带以及后来磁带和磁盘的做法，但在纯理论讨论时为了方便说明，我们通常选用前一种方式。
- ![](https://pic4.zhimg.com/80/v2-a0e8c204190e73aa563aee8231e74ccb_720w.jpg)

读写头该如何移动，移动之前或移动之后又该作何操作呢？
- 这取决于机器当前的状态，以及读写头当前所指小方格中的内容，机器中有着一张应对各种情况的**策略表**。
- 构造一台简单的图灵机，实现对纸带上所有3位二进制数的+1操作（超过3位的进位将被丢弃），相邻两个二进制数之间通过一个空的小方格隔开，形如下图所示，读写头从最右侧二进制数的最低位开始扫描，遇到连续2个空方格时认为已处理完所有数，机器停机。
- ![](https://pic2.zhimg.com/80/v2-e6046f3625fe5b55d4cd046ed086291d_720w.jpg)
- 策略表：E表示擦除、P表示打印、L表示左移。
  - <img src="https://pic1.zhimg.com/80/v2-b236f764ee2b1fee60b76400d3b01a20_720w.jpg" width="40%" >
  - 该图灵机有3种工作状态：+1、左移和判断
    - S1 是+1状态，也是机器的初始状态。如果读写头遇到的是0，则直接将0改为1即完成了+1任务，左移一格后进入状态 S2 ；如果遇到的是1，则将1改为0，由于需要进位，即对下一位+1，左移一格后仍留在状态 S1；如果遇到的是一个空方格，即使当前需要进位，也不做处理（将进位丢弃），左移一格后进入状态 S3 。
    - S2 是左移状态，此时已实现当前二进制数的+1，需要将读写头移到下一个数的最低位。如果遇到0或1，说明读写头还在当前二进制数上，继续左移；如果遇到空方格，后面等着它的可能是下一个二进制数，也可能是永无止境的空方格，左移一格之后进入状态 S3 。
    - S3 是判断状态，根据情况判断是否还有二进制数要处理。如果读写头遇到的是0或1，说明当前位置是一个新的二进数的最低位，直接交给 S1 处理；如果遇到的仍是空方格，说明后续不再有数据，停机。
  - <img src="https://pic4.zhimg.com/80/v2-04ec7765ec434701710f52ec43b30e63_720w.jpg" width="70%" >
- 如法炮制，可以设计出具有各种功能的图灵机，而策略表的制定则类似于**编程**。图灵想到，如果把策略表中的信息以统一的格式写成符号串（比如上表可以表达成S1/0/EP1L/S2 S1/1/EP0L/S1 S1//L/S3 ……），然后放在纸带的头部，再设计一台能在运行伊始时从纸带上读取这些策略的图灵机，那么针对不同的任务，就不需要设计不同的图灵机，而只需改变纸带上的策略即可。这种能靠纸带定制策略的图灵机，称为`通用图灵机`UTM（universal Turing machine）。
- 不单是策略表，其实用于描述图灵机的所有信息（包括所使用的符号、初始状态等）都可以表达成纸带上的符号串。这就意味着，一台图灵机可以成为另一台图灵机的输入。

判定问题的解答
- 试想一下，有些情况下，一台图灵机如果长时间没有输出结果，那么很可能陷入了**死循环**或永无止境的计算中。这是不愿看到的，因为机器可能运行1分钟后停机，也可能运行10天半个月甚至几十年才停机，亦或者永远也不会停机，这个很难靠人为判断。假设构建出一台图灵机H，接收其他图灵机及其输入信息作为输入，并能够判定其是否会停机，就解决了上面的烦恼——构建这样的机器难度虽大，但理论上是可行的。
这就是著名的**停机问题**（halting problem）。

H所处理的，本质上正是一种判定问题：某台图灵机在某输入上是否会停机。只要找到一台H判定不了的机器，希尔伯特的美梦就破灭了。

令H表现如下图所示，如果其判定对象会停机则输出1，反之输出0。
- <img src="https://pic1.zhimg.com/80/v2-8383f0d2038dd8e8b52eaf8f92cacc8c_720w.jpg" width="40%" >

再构建一台图灵机G，其运行流程如下图所示。如果H输出1，说明G会停机，但事实上它将陷入循环；如果H输出0，说明G不会停机，但事实上它将停机。
- <img src="https://pic4.zhimg.com/80/v2-8f244b5457adf4c0a05927f99fb1a337_720w.jpg" width="40%" >
悖论已经出现，H无法对G的停机问题进行判定。又一次归因于尴尬的自指：当一个系统强大到一定程度时，终究会遇到无法处理自己的窘境。

因此，**不存在一台图灵机，可以判定任意图灵机是否会停机**。图灵机不是万能的，判定问题的答案也是否定的。而这个看似有点耍赖的证明方式，有着图灵长达36页的数学论证支撑。


#### 图灵机意义

图灵的工作不仅回答了**希尔伯特**的问题，更参透了数学和计算机的本质关系——<font color='blue'>计算机是为解决数学问题而诞生的，却又基于数学，因而数学自身的极限也便框定了计算机的能力范围。</font>

图灵虽然证明了**没有任何机器可以解决所有数学问题**，却也证明了**机器可以完成所有人类能完成的计算工作**，从如今的应用看来，后一个结论的意义重大得多。

从图灵开始，计算机有了真正坚实的理论基础，更多人开始投身计算机的理论研究，而不仅是尝试构建一台机器。从如今的应用来看，图灵机之于计算机领域的价值远高于数学领域，毕竟判定问题还有λ演算和许多其他解答，但计算机的原始公式，只有图灵机这一个。

如今的**所有通用计算机都是图灵机的一种实现**，两者的能力是等价的。
- 当一个计算系统可以模拟任意图灵机（或者说通用图灵机）时，我们称其是**图灵完备**的（Turing complete）；
- 当一个图灵完备的系统可以被图灵机模拟时，我们称其是**图灵等效**的（Turing equivalent）。
- **图灵完备**和**图灵等效**成为衡量计算机和编程语言能力的基础指标，如今几乎所有的编程语言也都是图灵完备的，这意味着它们可以相互取代，一款语言能写出的程序用另一款也照样可以实现。


## 冯诺依曼

- ![](https://pic2.zhimg.com/80/v2-e4d433440561afc5f86bb3e14abd500f_720w.jpg)
- `冯·诺依曼`体系计算机又称存储程序计算，主要由以下几部分组成：
   - CPU（Central Processing Unit）：由控制器、运算器以及寄存器组成
   - 存储器（Memory）:即我们常说的内存
   - I/O设备：输入输出设备
- ![](https://pic2.zhimg.com/80/v2-7c443e162c8c42a605c63dedb96dda1e_720w.jpg)
- 主要特点
   - 程序存储执行
      - 计算机是靠诸多晶体管控制电路而运行，早期的计算机是靠手动控制电路执行，这种设计缺点在于，程序是一次性执行，即没办法存储起来反复执行；
      - 冯·诺依曼体系计算机，则提出了程序是可存储执行，即人们把要执行的程序存储在一个地方，然后在运行的时候让CPU去固定的地方去取，这样做的好处是程序可以存储起来多次运行，且修改程序不需要手动调整电路；
   - 二进制逻辑
      - 十进制逻辑的计数有利于人类阅读，但不利于电路设计，在电路中，状态一般有两种开启或者关闭，二进制逻辑的设计简化了计算机内部电路的设计
- 【2021-3-14】“冯·诺伊曼架构”，简单说就是要有 CPU，内存，显示器和键盘。用键盘给 CPU 下命令，CPU 和内存一起合作，算出结果输出给显示器就可以。
  - 不过 CPU 非常傻，只认识 0 和 1 两个数字。所以如果想算一道算数题，得告诉机器一串 24 位的数字 1000 0011 1100 0000 0000 0001（机器码，ADD %EAX, 1）, 他才能听懂。无论用 Python、C++ 还是别的编程语言，最终都会转换成这 24 个数字。
  - ![](https://p6-tt.byteimg.com/origin/pgc-image/a1515800335f48ae96ff652f84255185?from=pc)

- ![](https://pic1.zhimg.com/80/v2-92fdb4030ccc4cc1aacda3dd200291c9_720w.jpg?source=1940ef5c)

## 高德纳
- [Donald Knuth](https://www-cs-faculty.stanford.edu/~knuth/)，高德纳，《[计算机程序与设计](http://www-cs-faculty.stanford.edu/~uno/taocp.html)》作者，计算科学之父
   - 计算机科学技术中两个最基本的概念：“`算法`”(Algorithm)和“`数据结构`”(Data Structure)就是高德纳于 29 岁时提出来的
   - 艺术是人类智慧的最高形式
   - 高德纳是他的中文名，是 1977 年他访问中国之前所取的，命名者是姚储枫(姚期智的夫人，夫妇都是计算机科学家)。
   - [计算机鼻祖-Donald Knuth（高德纳） 的传奇](https://blog.csdn.net/gatieme/article/details/25613645)

![](http://5b0988e595225.cdn.sohucs.com/images/20180116/caa893f622634d1a8cf8e52f27a99bce.jpeg)

# 计算体系结构

## 计算机指令集

CPU的指令及构架，X86架构，Arm架构，微架构，还有手机处理器上的76、A55这些都是什么东西，它们之间到底是什么样的关系

参考：
- [Arm vs x86: Instruction sets, architecture, and all key differences explained](https://www.androidauthority.com/arm-vs-x86-key-differences-explained-568718/), [中文版](https://www.google.ae/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&cad=rja&uact=8&ved=0ahUKEwjf1tyj5ZzPAhWGWRQKHUoTDJAQFggaMAA&url=http%3A%2F%2Fwww.vaikan.com%2Farm-vs-x86-key-differences-explained%2F&usg=AFQjCNF1yxB0Q64ud33gwpMFqGz4gywKgg&bvm=bv.133178914,d.d24)
- [一文看懂arm架构和x86架构有什么区别](https://blog.csdn.net/bleauchat/article/details/90114342)

计算机的体系结构从指令集的复杂度上可以分两类
- 一类是复杂指令集CISC，主要是X86架构。
- 另一类是精简指令集RISC，这个比较多，主要是ARM、MIPS、PowerPC等。

目前x86和arm的能耗比已经差不多了，关键还是生态。现在大家都用arm指令集，自然软件，操作系统都对arm有各种优化，现在突然来个x86，小的应用厂商已经建立起arm的开发体系和人才队伍了，要真让他们在支持x86，那真是太难为他们了。大厂，比如苹果三星，都自己做处理器，也是arm指令集的，更加没有必要用x86了。应该说x86在移动端已经很难挤进去了

从CPU发明到现在，有非常多种架构，从我们熟悉的X86，ARM，到不太熟悉的MIPS，IA64，它们之间的差距都非常大。但是从最基本的逻辑角度可以分两大类，即所谓的“**复杂指令集** CISC ”与“**精简指令集** RISC”系统。 Intel和ARM处理器的第一个区别是，前者使用复杂指令集（CISC)，而后者使用精简指令集（RISC）。属于这两种类中的各种架构之间最大的区别，在于它们的设计者考虑问题方式的不同。

作者：[波心荡](https://www.zhihu.com/question/20148756/answer/103220283)

## 如何查看linux体系结构

[如何查看linux系统的体系结构](https://blog.csdn.net/lixuande19871015/article/details/90485929)

命令：

```shell
# (1) aarch64就是ARM架构
uname -a
# Linux tegra-ubuntu 4.4.38-tegra #1 SMP PREEMPT Fri Jul 28 09:55:22 PDT 2017 aarch64 aarch64 aarch64 GNU/Linux
uname -m
# 。。。。
file /bin/bash
# 含ARM
# /bin/bash: ELF 64-bit LSB executable, ARM aarch64, version 1 (SYSV), dynamically linked, interpreter /lib/ld-, for GNU/Linux 3.7.0, BuildID[sha1]=64c27467ad7a6c507c8f79464fea872fed5dd044, stripped
arch
# aarch64
cat /proc/cpuinfo # 查看cpu信息

# (2) x86架构
uname -a
# Linux ubuntu 4.4.0-21-generic #37-Ubuntu SMP Mon Apr 18 18:33:37 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux
uname -m # 返回 x86_64

file /bin/bash
# /bin/bash: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, for GNU/Linux 2.6.32, BuildID[sha1]=04eca96c5bf3e9a300952a29ef3218f00487d37b, stripped
arch
# x86_64 或i386

# (3) MIPS架构
uname -a
# Linux DrogooBox 3.3.8 #33 Tue Mar 22 15:02:01 CST 2016 mips GNU/Linux

```


## ARM —— 精简指令集

### 什么是ARM

ARM架构过去称作进阶精简指令集机器（AdvancedRISCMachine，更早称作：AcornRISCMachine），是一个32位精简指令集（RISC）处理器架构，其广泛地使用在许多嵌入式系统设计。由于节能的特点，ARM处理器非常适用于移动通讯领域，符合其主要设计目标为低耗电的特性 .

在今日，ARM家族占了所有32位嵌入式处理器75%的比例，使它成为占全世界最多数的32位架构之一。ARM处理器可以在很多消费性电子产品上看到，从可携式装置（PDA、移动电话、多媒体播放器、掌上型电子游戏，和计算机）到电脑外设（硬盘、桌上型路由器）甚至在导弹的弹载计算机等军用设施中都有他的存在。在此还有一些基于ARM设计的派生产品，重要产品还包括Marvell的XScale架构和德州仪器的OMAP系列.

### ARM架构

ARM构架图
- ![](http://file.elecfans.com/web1/M00/50/D9/o4YBAFr7zl2AGVr8AABPkxqzXZA667.jpg)

它由32位ALU、若干个32位通用寄存器以及状态寄存器、32&TImes;8位乘法器、32&TImes;32位桶形移位寄存器、指令译码以及控制逻辑、指令流水线和数据/地址寄存器组成.
- 1、ALU：它有两个操作数锁存器、加法器、逻辑功能、结果以及零检测逻辑构成。
- 2、桶形移位寄存器：ARM采用了32&TImes;32位的桶形移位寄存器，这样可以使在左移/右移n位、环移n位和算术右移n位等都可以一次完成。
- 3、高速乘法器：乘法器一般采用“加一移位”的方法来实现乘法。ARM为了提高运算速度，则采用两位乘法的方法，根据乘数的2位来实现“加一移位”运算;ARM高速乘法器采用32&TImes;8位的结构，这样，可以降低集成度（其相应芯片面积不到并行乘法器的1/3）。
- 4、浮点部件：浮点部件是作为选件供ARM构架使用。FPA10浮点加速器是作为协处理方式与ARM相连，并通过协处理指令的解释来执行。
- 5、控制器：ARM的控制器采用的是硬接线的可编程逻辑阵列PLA。
- 6、寄存器

## x86 —— 复杂指令集

![](http://file.elecfans.com/web1/M00/50/ED/pIYBAFr7zpSASlXUAABbDZ2xUGo091.jpg)

这个架构图并不是所有的都是如此，根据不同的主板，平台，架构是略有差别的比如说，目前很多主板已经将北桥集成到CPU当中，将南桥集成为PCH，但大致的框架还是如此的。下面对这个架构图上的各个内容分别进行一些简介:
- 1：CPU，大家都不陌生的名词，中央处理器，计算机的核心大脑。
- 2：北桥（North Bridge Chipset）：北桥是电脑主板上的一块芯片，位于CPU插座边，起连接作用。
- 3：南桥芯片（South Bridge）是主板芯片组的重要组成部分，一般位于主板上离CPU插槽较远的下方，PCI插槽的附近，这种布局是考虑到它所连接的I/O总线较多，离处理器远一点有利于布线。
- 4： 内存是计算机中重要的部件之一，它是与CPU进行沟通的桥梁。计算机中所有程序的运行都是在内存中进行的，因此内存的性能对计算机的影响非常大。
- 5：显卡（Video card，Graphics card）全称显示接口卡，又称显示适配器，是计算机最基本配置、最重要的配件之一。
- 6：显示接口
- 7：网卡是工作在链路层的网络组件，是局域网中连接计算机和传输介质的接口，不仅能实现与局域网传输介质之间的物理连接和电信号匹配，还涉及帧的发送与接收、帧的封装与拆封、介质访问控制、数据的编码与解码以及数据缓存的功能等。
- 8：声卡的基本功能是把来自话筒、磁带、光盘的原始声音信号加以转换，输出到耳机、扬声器、扩音机、录音机等声响设备，或通过音乐设备数字接口（MIDI）使乐器发出美妙的声音。
- 9：SATA（Serial Advanced Technology Attachment，串行高级技术附件）是一种基于行业标准的串行硬件驱动器接口，是由Intel、IBM、Dell、APT、Maxtor和Seagate公司共同提出的硬盘接口规范。
- 10：硬盘是电脑主要的存储媒介之一，由一个或者多个铝制或者玻璃制的碟片组成。碟片外覆盖有铁磁性材料。
- 11：总线

## x86 vs ARM

ARM采用了RISC，x86采用了CISC指令集，二者的差异表现在了能耗和速度上。RISC的能耗较低，但执行速度慢；x86的速度高能耗大。

从性能、扩展能力、操作系统的兼容性、软件开发的方便性及可使用工具的多样性及功耗这五个方面详细的对比了arm架构和x86架构的区别

### 一、性能 

X86结构的电脑无论如何都比ARM结构的系统在性能方面要快得多、强得多。X86的CPU随便就是1G以上、双核、四核大行其道，通常使用45nm（甚至更高级）制程的工艺进行生产；而ARM方面：CPU通常是几百兆，最近才出现1G左右的CPU，制程通常使用不到65nm制程的工艺，可以说在性能和生产工艺方面ARM根本不是X86结构系统的对手。

但ARM的优势不在于性能强大而在于效率，ARM采用RISC流水线指令集，在完成综合性工作方面根本就处于劣势，而在一些任务相对固定的应用场合其优势就能发挥得淋漓尽致.

### 二、扩展能力

X86结构的电脑采用“桥”的方式与扩展设备（如：硬盘、内存等）进行连接，而且x86结构的电脑出现了近30年，其配套扩展的设备种类多、价格也比较便宜，所以x86结构的电脑能很容易进行性能扩展，如增加内存、硬盘等.

ARM结构的电脑是通过专用的数据接口使CPU与数据存储设备进行连接，所以ARM的存储、内存等性能扩展难以进行（一般在产品设计时已经定好其内存及数据存储的容量），所以采用ARM结构的系统，一般不考虑扩展。基本奉行“够用就好”的原则.

### 三、操作系统的兼容性

X86系统由微软及Intel构建的Wintel联盟一统天下，垄断了个人电脑操作系统近30年，形成巨大的用户群，也深深固化了众多用户的使用习惯，同时x86系统在硬件和软件开发方面已经形成统一的标准，几乎所有x86硬件平台都可以直接使用微软的视窗系统及现在流行的几乎所有工具软件，所以x86系统在兼容性方面具有无可比拟的优势。

ARM系统几乎都采用Linux的操作系统，而且几乎所有的硬件系统都要单独构建自己的系统，与其他系统不能兼容，这也导致其应用软件不能方便移植，这一点一直严重制约了ARM系统的发展和应用。GOOGLE开发了开放式的Android系统后，统一了ARM结构电脑的操作系统，使新推出基于ARM结构的电脑系统有了统一的、开放式的、免费的操作系统，为ARM的发展提供了强大的支持和动力.

### 四、软件开发的方便性及可使用工具的多样性

X86结构的系统推出已经近30年，在此期间，x86电脑经过飞速发展的黄金时期，用户的应用、软件配套、软件开发工具的配套及兼容等工作，已经到达非常成熟甚至可以说是完美的境界。所以使用X86电脑系统不仅有大量的第三方软件可供选择，也有大量的软件编程工具可以帮助您完成您所希望完成的工作。

Arm结构的电脑系统因为硬件性能的制约、操作系统的精简、以及系统兼容等问题的制约，造成Arm结构的电脑系统不可能像X86电脑系统那样有众多的编程工具和第三方软件可供选择及使用，ARM的编程语言大多采用C和JAVA。

对这一点的比较，更直接的结论是：基于x86结构电脑系统平台开发软件比arm结构系统更容易、更简单、实际成本也更低，同时更容易找到第三方软件（免去自己开发的时间和成本），而且软件移植更容易。

从以上对比分析，给了我们的一个很清晰的感觉，ARM和X86结构的电脑根本就无法对比，ARM根本就不是X86电脑的的对手。是的，如果只考虑上述几个方面的要数，ARM确实无法与X86电脑竞争，甚至连比较的资格都没有。但是近1、2年，ARM的产品在终端应用特别是手持终端应用飞速发展（如：智能手机、平板电脑等），其销售数量已经远远超出x86结构的电脑销售数量，可见ARM是具有其与X86结构电脑不可对比的优势。该优势就是：功耗.

### 五、功耗 

X86电脑因考虑要适应各种应用的需求，其发展思路是：性能+速度。20多年来x86电脑的速度从原来8088的几M发展到现在随便就是几G，而且还是几核，其速度和性能已经提升了千、万倍，技术进步使x86电脑成为大众生活中不可缺少的一部分。但是x86电脑发展的方向和模式，使其功耗一直居高不下，一台电脑随便就是几百瓦，即使是号称低功耗节能的手提电脑或上网本，也有十几、二十多瓦的功耗，这与ARM结构的电脑就无法相比.


# 编程语言

[编程语言分类与关系](https://blog.csdn.net/coding_dong/article/details/80920571)

## 编程语言大全

各门语言难度：[C++ 最难学？最易/难学习的编程语言 TOP 5 来了](https://www.toutiao.com/i7047434834607931940/)
- ![img](https://p26.toutiaoimg.com/origin/tos-cn-i-tjoges91tu/St4ODUM6UmOGe6)

### 高级语言 vs 低级语言

高级语言并不是特指的某一种具体的语言，而是包括很多编程语言：
- 如流行的java，c，c++，python，易语言，JavaScript等等，这些语言的语法、命令格式都不相同。

低级语言分`机器语言`（二进制语言）和`汇编语言`（符号语言），这两种语言都是面向**机器**的语言，和具体机器的指令系统密切相关。
- `机器语言`用**指令代码**编写程序，而`符号语言`用**指令助记符**来编写程序。
- 低级语言包括机器语言（0或1组成的一串代码）和汇编语言（将常用的机器代码用一些标记符代替）。

高级语言包括c c++ java c# 等等。这些语言符合开发者的思维习惯，可以不需要多计算机硬件有过多的了解。也可以进行程序开发。

### 编程语言变迁

【2022-10-8】[编程语言变迁图](https://www.infoq.cn/article/7eywx_3ap7drb5ledzup)，[原图](https://apenwarr.ca/img/programmer-migration.svg)
- ![](https://static.geekbang.org/infoq/5cd27e1a0383b.png)
- 终极节点包括：Rust、 Java、 Go、 Python 3、Javascript 和 node.js（node.js 作为一种特殊的 Javascript，在这里特别指出）

高级语言都是用什么语言写的？
- `C语言`（偏向底层的硬件性编程语言）
  - C语言是一门通用计算机编程语言，应用广泛。C语言的设计目标是提供一种能以简易的方式编译、处理低级存储器、产生少量的机器码以及不需要任何运行环境支持便能运行的编程语言。
  - 尽管C语言提供了许多低级处理的功能，但仍然保持着良好跨平台的特性，以一个标准规格写出的C语言程序可在许多电脑平台上进行编译，甚至包含一些嵌入式处理器(单片机或称MCU)以及超级电脑等作业平台。
- `Shell`语言 ← `C语言`
  - Shell 是一个用C语言编写的程序，它是用户使用Linux 的桥梁。 Shell 既是一种命令语言，又是一种程序设计语言。 Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。
- `Python`（脚本语言）← `C语言`
  - Python的底层是用C语言写的，很多标准库和第三方库也都是用C写的，运行速度非常快
  - Python是纯粹的自由软件， 源代码和解释器CPython遵循 GPL(GNU General Public License)协议 。Python语法简洁清晰，特色之一是强制用空白符(white space)作为语句缩进。Python具有丰富和强大的库。它常被昵称为胶水语言，能够把用其他语言制作的各种模块(尤其是C/C++)很轻松地联结在一起。
  - 最初的Python用 C语言编写实现，又称为 CPython。一般所讨论的Python其实就是 CPython。
  - 随着编程语言的不断发展，Python 的实现方式也发生了变化，除了用 C 语言实现外，Python 还有其他的实现方式。
  - 用 `Java` 语言实现的 Python 称为 `JPython`
  - 用 `.net` 实现的 Python 称为 `IronPython` 等等。
  - PyPy 可能是最令人兴奋的 Python 实现，因为其目标就是将 Python 重写为 Python。在 PyPy 中，Python 解释器本身是用 Python 编写的。
- `Java`语言 ← `C语言`
  - Java是由C语言发展而来的高级语言，并且内核是由c编写的。JAVA虚拟机（JVM）是用`C语言`和`汇编语言`编写的
  - Java是面向对象编程语言，从C++发展而来的, 不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。
- `JavaScript` 语言
  - JavaScript®（通常简写为JS）是一种轻量的、解释性的、面向对象的头等函数语言，其最广为人知的应用是作为网页的脚本语言，但同时它也在很多非浏览器环境下使用。 JS 是一种动态的基于原型和多范式的脚本语言，支持面向对象、命令式和函数式的编程风格。
  - google chrome的js引擎是v8，nodejs用的也是这个，据说是目前速度最快的，用c++写的，[代码](http://code.google.com/p/v8/)
- `PHP`语言：(超文本预处理器) ← `C语言`
  - PHP语言的内核就是C语言写成的。
  - PHP(外文名:PHP: Hypertext Preprocessor，中文名：“超文本预处理器”)是一种通用开源脚本语言。语法吸收了C语言、Java和Perl的特点，利于学习，使用广泛，主要适用于Web开发领域。PHP 独特的语法混合了C、Java、Perl以及PHP自创的语法。
- `Go`语言 ← `C语言`
  - 早期Go是用`汇编语言`和`C语言`实现的，后来Go成熟了之后，Go语言就开始**自举**、用早期版本重写了Go语言编译器
- Node.js ← `C++`
  - Node.js是使用C++语言写的。 nodejs是用C++开发的一种运行于服务器端的语言，node的底层是C++；且nodejs是一个基于Chrome V8引擎的JavaScript运行环境，而V8是使用C++开发的。
- Perl ← `C语言`
  - Perl是一种动态的，高级的、通用的编程语言，它没有任何官方缩写。 它是纯粹使用C编程语言开发和实现的;
- Ruby ← `Perl`
  - Ruby，一种简单快捷的面向对象（面向对象程序设计）脚本语言，在20世纪90年代由日本人松本行弘(Yukihiro Matsumoto)开发，遵守GPL协议和Ruby License。它的灵感与特性来自于 Perl、Smalltalk、Eiffel、Ada以及 Lisp 语言。由 Ruby 语言本身还发展出了JRuby（Java平台）、IronRuby（.NET平台）等其他平台的 Ruby 语言替代品。

### 十大编程语言诞生

- [十大编程语言诞生时间](https://inews.gtimg.com/newsapp_bt/0/12180976824/1000)
  - [十大编程语言的鼻祖，有的大学都没读完，有的已然离世](https://new.qq.com/rain/a/20200730A0OAPL00)
  - ![](https://inews.gtimg.com/newsapp_bt/0/12180939788/1000)

|编程语言|发明时间|发明人|头像|介绍|
|---|---|---|---|---|
|C|1972|丹尼斯·里奇，Dennis MacAlistair Ritchie|![](https://inews.gtimg.com/newsapp_bt/0/12180971661/1000)|C语言之父，是图灵奖的获得者，也是UNIX之父，因为C语言最初就是为UNIX量身定做的。美国人，1941年出生，27岁获得数学博士学位，在1969年至1973年间，为了移植与开发UNIX作业系统，丹尼斯·里奇与肯·汤普逊，以B语言为基础，在贝尔实验室设计、开发出来c语言。2011年10月12日去世，享年70岁|
|C++|1979|布贾尼·斯特劳斯特卢普（BjarneStroustrup）|![](https://inews.gtimg.com/newsapp_bt/0/12180971662/1000)|C++之父，1950年出生，丹麦人。名字太长，简称B·S，先后读过丹麦奥胡斯大学和英国剑桥大学。1979年，29岁的他经过反复研究和测试当时流行的几种程序语言后取长补短，将编程技术和语言支持相结合，开发出超越传统的“面向对象”编程的“C with Classes”（带类的C），也就是C++的雏形，1998年正式命名C++。|
|Python|1989|吉多·范罗苏姆（Guido van Rossum）|![](https://inews.gtimg.com/newsapp_bt/0/12180972815/1000)|外号龟叔，1956年出生，荷兰人，26岁在阿姆斯特丹大学获得数学和计算机科学硕士学位。1989年圣诞节，33岁的龟叔为打发时间，决定为当时正构思的一个新的脚本语言编写一个解释器。当时电视上非常流行一个电视剧蒙提·派森的飞行马戏团，作为这个马戏团的狂热粉丝，他以Python命名该项目，使用C进行开发，于是Python就诞生了。|
|Java|1990|詹姆斯·高斯林（James Gosling）|![](https://inews.gtimg.com/newsapp_bt/0/12180973617/1000)|1955年出生在加拿大一个小村庄，12岁就会利用废物做电子游戏机和修理报废收割机，22岁获得计算机学士学位，28岁博士毕业并开始工作，1990年（35岁）与人合作“绿色计划”并发展一套语言叫做“Oak”，后改名为Java。|
|Ruby|1993|松本行弘(Yukihiro Matsumoto)|![](https://inews.gtimg.com/newsapp_bt/0/12180973618/1000)|1965年出生，日本人，日本筑波大学毕业。Ruby是一种面向对象的计算机编程语言。由日本人松本行弘于1993年发明，明显比其他类似的编程语言（如Python）年轻，又因为Ruby是日本人发明的，所以早期的非日文资料和程序都比较贫乏，所以在网上仍然可以找到Ruby的资料太少之类的批评。约于2000年，Ruby开始进入美国，英文的资料开始发展。Ruby归根结底源于Perl和Python两类语言，与C，C++，C#，java是不同大类。|
|JavaScript|1995|布兰登·艾奇（Brendan Eich）|![](https://inews.gtimg.com/newsapp_bt/0/12180973619/1000)|1961年出生，美国人，毕业于伊利诺伊大学香槟分校。原名LiveScript，起初它的主要目的是处理以前由服务器端负责的一些表单验证。1995年34岁的布兰登·艾奇加入了当时走在技术革新最前沿的Netscape（网景）公司，他尝试用LiveScript同时在浏览器和服务器中使用。为了赶在发布日期前完成LiveScript的开发，Netscape与Sun公司成立了一个开发联盟。而此时，Netscape为了搭上媒体热炒Java的顺风车，临时把LiveScript改名为JavaScript。|
|R语言|1995|Ross Ihaka和Robert Gentleman|![](https://inews.gtimg.com/newsapp_bt/0/12180974941/1000)|创始人有两个：<br>（1）乔治·罗斯·伊哈卡（George Ross Ihaka），1954年出生，美国人，加州大学伯克利分校获得博士学位。<br>（2）罗伯特·克利福德·杰特曼（Robert Clifford Gentleman），1959年出生，加拿大人，不列颠哥伦比亚大学获得主修数学的理学士学位，华盛顿大学统计学博士学位。<br>R语言前身是1976年美国贝尔实验室开发的S语言，1995年正式问世，因两名主要研发者Ross Ihaka和Robert Gentleman姓名首字母均为R而得名。可惜两人已分道扬镳，各奔前程，开发和维护工作由早期核心团队的其他成员来共同接管。|
|PHP|1995|拉斯马斯·勒德尔夫（Rasmus Lerdorf）|![](https://inews.gtimg.com/newsapp_bt/0/12180974943/1000)|1968年出生，国籍加拿大-丹麦，加拿大滑铁卢大学(University of Waterloo)大学系统设计工程专业应用科学学士。<br>在1994创建PHP，刚刚开始只是一个简单的用Perl语言编写的程序，用来统计他自己网站的访问者。后来又用C语言重新编写，包括可以访问数据库。1995年他发布了PHP1.0版本，到现在最新版本PHP8.0已有25个年头，各方面特性不断在加强，近几年更是发展迅猛，从编程语言排行榜50名开外挤进了前10，进步神速。|
|C#|2000|安德斯·海尔斯伯格（Anders Hejlsberg）|![](https://inews.gtimg.com/newsapp_bt/0/12180976820/1000)|1960年出生，丹麦人。在丹麦技术大学读过书，与众不同的是他没毕业，但无妨，他是当时世界上少有的编程天才<br>在安德斯加入微软后，成为微软开发工具大军的领军人物，微软的编译器技术飞速提高，C#也就是在2000年由微软发布，.net framework也紧跟着在2002年发布，安德斯迎来了真正的人生的巅峰。|
|Go|2009|罗布·派克（Rob Pike）|![](https://inews.gtimg.com/newsapp_bt/0/12180976822/1000)|1956年出生，加拿大人，这个人实在不知道该怎么介绍，在他身上有太多不同类别的闪光点|

Go之父闪光点
- ● Unix 的先驱，贝尔实验室初期开发猛人；
- ● 全能型程序员，从操作系统写到编译器，又从文本编辑器写到了 UI 界面；
- ● 1980 年的奥运会射箭项目夺得了银牌；
- ● 业余天文学家，设计的珈玛射线望远镜差点被 NASA 用在航天飞机上；
- ● 1990年他上了电视，参与了大卫莱特曼的电视节目《Late Night with David Letterman》。
- ● 1992年研发了UTF-8，涉足前沿科技的量子计算和通讯领域；
- ● 两部编程语言经典之作《Unix 编程环境》和《程序编程实践》的笔者；
- ● 2003年翻车断了身上很多零件；
- ● 2009年，由罗布·派克主导研发GO语言在谷歌发布面世；

### 编程语言关系

编程语言演化图
- 点击对应编程语言，可以跳转到编程语法笔记

<div class="mermaid">
%% 编程语言演化图
    graph TD
    A(汇编语言):::s
    classDef s fill:#f02;
    style A fill:#C8D64B;
    style B fill:#6BE0F7;
    style C fill:#5CF77B;
    style D fill:#6BE0F7;
    style F fill:#5CF77B;
    %%style H fill:#5CF77B;
    style I fill:#6BE0F7;
    style J fill:#F7CF6B;
    A -->|1972,高级语言| C(C语言)
    C -->|操作机器| B(Shell)
    C -->|1989,脚本语言| D(Python)
    C -->|虚拟机| E(Java)
    A -->|1990,高级语言| E(Java)
    C -->|1979,面向对象| F(C++)
    F -->|面向对象| E
    F -->|1995,Netscape| G(JavaScript)
    %%E -.->|蹭热度| G
    F -->|服务端| J(Node.js)
    C -->|Web后端,1995| H(PHP)
    A -->|2009,Google| I(Go)
    C -->|高级语言| I
    C -->|脚本语言| K(Perl)
    K -->|1993,脚本语言| L(Ruby)
    K -.-> H
    C -->|2000,Microsoft| M(C#)

    click B "https://wqw547243068.github.io/linux#shell语言" "shell用法"
    click C "https://wqw547243068.github.io/c#c语言" "c/c++语言"
    click D "https://wqw547243068.github.io/python" "Python语言"
    click F "https://wqw547243068.github.io/c#c" "c/c++语言"
    click G "https://wqw547243068.github.io/web#js" "web开发"
    click I "https://wqw547243068.github.io/go" "go语言"
</div>

### 语言汇总

- TIOBE 公司，每月会发布一版编程语言的流行度[排行榜](https://www.tiobe.com/tiobe-index/)
- 语言类型分布图：[知乎](https://www.zhihu.com/question/19918532)，[img](https://img-blog.csdn.net/20180705132612202?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NvZGluZ19kb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  - 划分维度：动态(dynamic)/静态(static)、强类型(strong)/弱类型(weak)
  - static & weak: C、C++
  - static & strong: Java
  - dynamic & weak: JavaScript、Perl、PHP、VB
  - dynamic & strong: Python、Ruby、Erlong
- [一图看懂编程语言分类](https://blog.csdn.net/acelit/article/details/62466679)，[img](https://img-blog.csdn.net/20170316225437760)
  - Venn图，多个维度混合：编译型/解释型、动态类型/静态类型、强类型/弱类型、动态/静态
- 各语言[关系图谱](https://exploring-data.com/vis/programming-languages-influence-network/)：（可交互）
- 国外有一篇对主流编程语言进行优劣点评的文章《[These Modern Programming Languages Will Make You Suffer](https://betterprogramming.pub/modern-languages-suck-ad21cbc8a57c)》，非常精彩，强烈建议看一下。对其中 Meta Language 部分的翻译，见 《[一文解决现代编程语言选择困难：响应式编程](https://www.infoq.cn/article/zCMypl8ZzgT9U60sbZ9x)》
- 从计算机最底层的硬件开始，按照贴近硬件的程度，主流编程语言的层次依赖关系图，[img](https://static001.geekbang.org/infoq/d3/d3cf643a29e9f428cc414994660ab0e4.jpeg)
  - 从底向上逐层依赖：**硬件层级** → **汇编层级**（机器语言/汇编语言） → **系统层级**（C语言） → **应用层级**（C++/Java/object-c等） → 脚本层级（Python/JavaScript/Ruby/Perl）
  - C 语言在计算机技术中有其它任何高级语言不可替代的作用。所谓 “0/1 生汇编，汇编生 C，C 生万物，乃编程之本”，任何想立志学好计算机的人都不可能跨过 C 语言。
  - C 语言是面向**内存**的编程语言，用 C 编程的时候，需要知道每个数据在内存中样子，是直接在和计算机对话的。而其它语言，都是做各种各样的封装，屏蔽掉了底层的各种概念，让你都不知道计算机是怎么工作的。
  - 知乎上有人给了一个比喻：如果不会 C 语言，以为自己学会了编程，其实嘛，在“编程”这个“城市”里是没有买“房子”的，没有房子就没有门，说白了，就是没入门，也就是门外汉。
  - 系统地学习 C 语言，在实际产品研发中大规模使用 C 语言，会使你深刻掌握计算机底层的原理与机制，这才是是否能成为“牛”人的根本所在。
- [九种编程语言大对比（图文版）](https://blog.csdn.net/kymdidicom/article/details/113449578)，9张信息图囊括了九种主流编程语言：Python、Java、C、C++、JavaScript、C#、Ruby、PHP以及Objective-C。对于每种编程语言，大家都能够看到由其打造的顶级应用成果，相关职位的平均薪酬（美国）以及该语言的优势与弊端。

### 新语言

- 【2022-9-19】[凹语言](https://wa-lang.org/)
- Unilang 目标是成为一门现代的通用目的编程语言，能够有效、灵活地开发桌面环境应用，去统筹解决现有不足的新的方案中的语言部分，[深度deepin开源自研编程语言：Unilang](https://mp.weixin.qq.com/s/eJJijQpMTYmt42Ihzdjdig)

### 发展历史

[计算机编程语言发展史](https://www.cnblogs.com/ambitious-to-49/p/10146437.html), 凹语言™（凹读音“Wa”）是 柴树杉、丁尔男、史斌 针对 WASM 平台设计的的通用编程语言，支持 Linux、macOS 和 Windows 等主流操作系统和 Chrome 等浏览器环境

主体脉络：**机器**语言 -> **汇编**语言 -> **高级**语言
- **机器**语言：最初的计算机所使用的是由“0”和“1”组成的二进制数，二进制是计算机的语言的基础。计算机发明之初，计算机只能被少部分人使用，人  们需要用0、1组成的指令序列交由计算机执行，对于机器语言的使用与普及都是很令人头疼的问题。对于程序的移植能力几乎没有，从而时间成本，人力成本十分昂贵。但机器语言也不是没有优势，由于这种语言是直接对计算机硬件进行操作，所以在特定型号的计算机上面，运算效率也是很高的，机器语言的出 现对于未来的计算机语言发展起到了很好的推动作用，所以机器语言也是第一代计算机语言。
- **汇编**语言：汇编语言是在机器语言的基础上诞生的一门语言，用一些简洁的英文字母、符号串来替代一个特定的指令的二进制串，这也提高了语言的记忆性和识别性。对于程序的开发与维护起到了积极作用。汇编语言同样也是直接对硬件进行操作，这样依然局限了它的移植性。但是使用汇编语言针对计算机特定硬件而编制的汇编语言程序，对于计算机硬件的功能和特长的发挥已有了很大进步，它精炼而质量高，所以至今仍是一种常用的程序开发语言。
- **高级**语言：在与计算机的不断交流中，人们对计算机程序的移植性需求不断提高，此时急需要一种不依赖于特定型号的计算机的语言，用这种语言编写的程序能在在各种平台都正常运行。从最初的语言诞生至今，已经相继出现了几百种语言。高级语言的发展也从最初的结构化语言发展成为面向过程语言设计和面向对象语言设计。面向过程语言设计的代表有：C语言，Fortran，cobol，pascal，ada等等一系列语言，而面向对象语言设计的代表则为：java, c++,c#等。对于面向过程的程序来说，执行顺序是流水线似的，在一个模块被执行完成前，人们不能干别的事，也无法动态地改变程序的执行方向，这恰恰与人们的日常处理事情的方式相矛盾。而对于面相对象的程序设计来说，很好的将事物象的部分抽取归类，各个累与模块之间能相互组合，完成特定的功能，同时又能重复使用。对使用者的技术要求也相对降低。

计算机编程语言的发展史：**机器**语言 -> **汇编**语言 -> **高级**语言
- 1940s，产生了真正意义上的电子计算机，这个时期的语言由于内存和计算能力的有限，都是使用硬件相关的**汇编**语言；
- 1950s~1960s，随着电子技术的进步，计算机进入大型机时代，一些**高级**语言被逐渐开发出来主要用于系统级编程和数学计算，
  - Fortran（1950s由IBM团队发明的数学计算语言），
  - COBOL（1950s由IBM等行业领袖推行的金融、商务系统开发语言），
  - LISP（用于人工智能领域，主要的数据结构是Linked List，全名为List Process语言，引入了很多先进的特性如递归、动态类型、自动内存管理等特性）
  - ALGOL（用于算法描述、学术领域，引入嵌套结构，语法范围等，很大的影响了BPCL，B，PASCAL等语言
  - Basic（最早是为给非科学领域的学生所编写，Microsoft VB的前身）
- 1970s，产生了C语言和一些早期的**面向对象**编程语言
  - C（1970s由Dennis Ritchie和Brian Kernighan发明的为DEC机开发的系统编程语言，前身是BPCL，B语言）
  - Simula（第一个支持面向对象的编程语言）
  - SmallTalk（第一个完整实现面向对象特性的编程语言）
- 1980s，向PC时代过渡，语言特性的合并、优化、发展
  - C++（综合了SmallTalk面向对象特性和C语言语法，最为广泛应用的面向对象语言之一）
  - MATLAB（工业领域，工程计算语言）
  - Objective-C（iOS编程语言，已经是Top5的语言之一）
  - Erlang（多重范式编程语言，函数式、并发式、分布式，80年代由爱立信发明用于通信网络编程，现已广泛应用于互联网高并发分布式计算领域，最有名的作品
  - 括CouchDB/RabbitMQ）
  - Perl（源于Unix脚本的动态语言，初衷是为了使报告更容易处理，借鉴了C/sh/AWK和SED）
  - Tcl（曾经是很流行的测试脚本语言，现在已经没落）
- 1990s，PC时代，互联网时代萌芽，产生了很多动态语言和可视化编程集成环境IDE
  - Windows由于垄断PC市场，其基于VC/VB的桌面应用开发曾经是客户端开发技术的主流，随之而来催生了大量的基于Windows SDK客户端应用，MFC是其中最为知名的一个C++类库实现 Python/Ruby/Lua/PHP/JS
  - Java（发展为3个体系，J2SE/J2EE/J2ME，J2EE包含一些企业特性如JDBC, JPA, JTA/JMS/EJB，J2ME是移动版本）
  - Visual Basic/Visual C++/Delphi（Object Pascal）/Power Builder
  - Javascript（浏览器客户端脚本，Netscape发明，包含ECMAScript核心脚本, DOM文档对象模型, BOM浏览器对象模型三部分）
- 2000s~现在, 互联网/移动互联网时代，C/S模式进化为B/S模式，Java/PHP/.Net大行其道，并行计算/分布式计算越来越重要
  - ActionScript（Adobe公司发明，面向对象的Flash开发语言）
  - C#/Visual Basic.Net
  - Groovy（由VMVare支持，基于Java平台的动态语言，支持元数据编程Metaprogramming，动态扩展对象数据，如反射，
- 还比如范型编程（如C++的STL，最早版本由HP实现）能为语言提供运行时再确定的动态类型特性，可以大大简化编码）
  - Go （C语言之父发明的并行计算语言）
  - Node.js（服务器端的JS运行环境，Js语言在服务器端的延伸，具有单线程，高并发的特性）


### Python太低级？

- 各种编程语言之间确实有高低级之分，但不是培训班 Tony 老师告诉的高低级。 
  - ADD %EAX, 1 叫做**汇编**语言，是低级语言，而 Python 和 C++ 则同属于**高级**语言范畴。
  - C++ 是基于 C 语言“改进”而来，Python 则是由 C 语言编写的。
- 那么 Python 和 C++ 谁更高级呢？
  - 在数据科学和人工智能领域，Python 是当之无愧的王者
  - 但在高频交易、网络游戏领域，C++ 可以说是目前的业界标准。
  - 对于少儿编程领域来说，Python 在简单易入门方面几乎没有对手。
- Python 有多简单呢？写一个同样功能的网站，用汇编语言，C++ 与 Python 的工作量对比大约是 1000000:3:1
- Python 和 C++ 的真正区别是**编译型**语言与**解释型**语言的区别，简单来说就是 C++ 是直接变成 0101 让 CPU 运行的，而 Python 则需要随身带个翻译，这就导致 Python 在运行时比 C++ 慢 10 - 100 倍左右。不过不用担心，现在的 CPU 已经快到让你感觉不到任何区别。
- 为什么 Tony 老师说 C++ 比 Python 高级呢？当然是因为学同样的东西，他能收 3 倍的课时费，贵的就高级，没毛病。
  - Tony 老师也许会反驳说 Python 只是玩具语言，大一点的孩子都不用。
  - 我们可以看一下 2016 ～ 2020 编程语言流行度排行榜:
    - ![](https://p3-tt.byteimg.com/origin/pgc-image/b967e918b1824010b6c94ba760438f89?from=pc)
- 参考
  - 【2021-3-14】[Python太低级，我选 C++？码农带你揭穿少儿编程的骗局](https://www.toutiao.com/i6921532950840476174)

## 编译型 vs 解释型

编译型语言和解释型语言
- 计算机不能直接的理解**高级语言**，只能直接理解**机器语言**，所以必须要把高级语言翻译成机器语言，计算机才能执行高级语言的编写的程序。翻译的方式有两种，一个是**编译**，一个是**解释**。两种方式只是翻译的**时间**不同。

### 编译型

编译型语言：
- 需通过**编译器**（compiler）将源代码编译成机器码，之后才能执行的语言。一般需经过**编译**（compile）、**链接**（linker）这两个步骤。
  - ![img](https://img-blog.csdn.net/20180705132835717?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NvZGluZ19kb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
- 编译是把源代码编译成机器码，链接是把各个模块的机器码和依赖库串连起来生成可执行文件。编译和执行是分开的，但是**不能跨平台**。
- 优点：
  - 编译器一般会有预编译的过程对代码进行优化。因为编译只做一次，运行时不需要编译，所以编译型语言的程序**执行效率高**。可以脱离语言环境独立运行。
- 缺点：
  - 编译之后如果需要修改就需要整个模块重新编译。编译的时候根据对应的运行环境生成机器码，不同的操作系统之间移植就会有问题，需要根据运行的操作系统环境编译不同的可执行文件。
- 代表语言：C、C++、Pascal、Object-C、swift等


### 解释型

解释型语言
- 解释性语言的程序不需要编译，相比编译型语言省了道工序，解释性语言在运行程序的时候才逐行翻译。每一个语句都是执行的时候才能翻译。这样解释性语言每执行一次要翻译一次，**效率较低**。
  - ![img](https://img-blog.csdn.net/20180705132541162?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NvZGluZ19kb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
- 优点：
  - 有良好的平台兼容性，在任何环境中都可以运行，前提是安装了解释器（虚拟机）。
  - 灵活，修改代码的时候直接修改就可以，可以快速部署，不用停机维护。
- 缺点：
  - 每次运行的时候都要解释一遍，性能上不如编译型语言。
- 代表语言：JavaScript、Python、Erlang、PHP、Perl、Ruby

### 混合型

混合型语言
- 混合型语言也叫**半编译型**语言。比如java、C#，C#在编译的时候不是直接编译成机器码而是**中间码**，.NET平台提供了中间语言运行库运行中间码，中间语言运行库类似于**Java虚拟机**。.net在编译成IL代码后，保存在dll中，首次运行时由JIT在编译成机器码缓存在内存中，下次直接执行。
  - ![img](https://img-blog.csdn.net/20180705132554135?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NvZGluZ19kb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
- Java解释器 采用生成与系统无关的字节代码指令技术。也就是说，在任何不同的操作系统上，只要正确安装了java运行系统，就有了编写调试java程序的平台，在分布式应用中，java的这个特点使同一个java程序能在不同的系统上运行，从而提高了软件生产效率。可移植性是跨平台特性的一个延伸，即具有了跨平台性，就保证了可移植性。java程序、java类库、java编译器、java系统都具有可移植性。
- 另外有一个特殊的情况，正常情况下JavaScript属于解释性语言，V8引擎是被设计用来提高网页浏览器内部JavaScript执行的性能，为了提高性能，v8会把js代码转换为高效的机器码，而不在是依赖于解释器去执行。v8引入了JIT在运行时把js代码进行转换为机器码。这里的主要区别在于V8不生成字节码或任何中间代码。这里的特殊之处在于JIT做代码优化(同时生成编译版本)；解释型语言无法做到这些。

## 强类型语言和弱类型语言

### 强类型语言

强类型语言，一旦一个变量被指定了某个数据类型，如果不经过强制类型转换，那么它就永远是这个数据类型。你不能把一个整形变量当成一个字符串来处理。
- 主要语言：Java、C#、Python、Object-C、Ruby

### 弱类型语言

数据类型可以被忽略，一个变量可以赋不同数据类型的值。一旦给一个整型变量a赋一个字符串值，那么a就变成字符类型。
- 主要语言：JavaScript、PHP、C、C++（C和C++有争议，但是确实可以给一个字符变量赋整形值，可能初衷是强类型，形态上接近弱类型）


## 动态和静态

主要针对点是：运行时是否能够改变代码结构。

注意：
- 通常情况下**解释型**语言是**动态**类型语言，**编译型**语言是**静态**类型语言。但也不全是
  - swift是编译型语言但是它也是动态类型语言
  - C#和Java是解释型语言也是静态类型语言。

### 动态结构语言

是一类在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构。
- 主要动态语言：Object-C、C#、JavaScript、PHP、Python、Erlang。

对数据类型检查的时间
- 动态语言是在运行时确定数据类型的语言。变量使用之前不需要类型声明，通常变量的类型是被赋值的那个值的类型。
- 主要语言：Python、Ruby、Erlang、JavaScript、swift、PHP、SQL、Perl。

### 静态结构语言

与动态语言相对应的，运行时结构不可变的语言就是静态语言。
- 如Java、C、C++。

对数据类型检查的时间
- 静态语言是在编译时变量的数据类型即可确定的语言，多数静态类型语言要求在使用变量之前必须声明数据类型。 
- 主要语言：C、C++、C#、Java、Object-C

## 执行速度

多种编程语言执行速度对比：
- ![](https://p3.toutiaoimg.com/img/tos-cn-i-qvj2lq49k0/eb193ff464674be29b84675497b7f91e~tplv-obj:1913:1040.image?from=post)

以斐波那契数列计算为例，对比各种语言的性能
- **编译**速度：GO > C > JS > PHP > C++ > Java > Python
- **运行**速度：C++ > C > GO > Java > JS > PHP > Python

|编程语言|编译时间|运行时间|备注|
|--------|---|---|---------------|
|Go 1.14|0.09s|0.04s|go build f.go|
|Java 1.8|1.2s|0.14s|javac f.java|
|C|0.14s|0.03s|gcc-6 -O2 -o c.bin f.c|
|C++ 14|0.8s|0.03s|g++-6 -O2 -o a.bin f.cpp|
|Python 3|3.6s|3.6s|编译+执行一起: python3 f.py|
|PHP 7|0.8s|0.8s|编译+执行一起: php f.php|
|JS Node|0.33S|0.33S|编译+执行一起: node f.js|


## 计算机课程

计算机速成课 [Crash Course Computer Science](https://thecrashcourse.com/courses/computerscience)，Carrie Anne Philbin在本课程以入门级大学材料和AP计算机科学原理指南为基础。 笔记：[CPU中的程序是怎么运行起来的](https://blog.csdn.net/wgp2hpp/article/details/110790031)
1. 概述计算机的历史以及为我们提供现代计算机的设计决策
2. 描述编程和软件的基本要素
3. 确定计算机硬件的基本组件及其作用
4. 描述如何使用计算机以及计算机如何随着时间演变
5. 了解计算机的普及程度以及

[Youtube地址](https://www.youtube.com/playlist?list=PL8dPuuaLjXtNlUrzyH5r6jN9ulIgZBpdo)

<iframe src="//player.bilibili.com/player.html?aid=457294840&bvid=BV145411j7aH&cid=242822115&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"  height="600" width="100%"> </iframe>

## 代码如何被CPU执行

[简单！代码原来是这样被CPU跑起来的](https://www.cnblogs.com/jiazhuangdongbiancheng/p/15521829.html)

- <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8463b24f49d4c50a51ccfe5900ff0fc~tplv-k3u1fbpfcp-watermark.awebp" width="70%" >

像C++/java/python这些高级语言写的程序没法被直接运行，因为计算机只认识0、1这样的二进制，简称**机器码**，我们写的代码（高级语言）需要替换成机器码，计算机才能执行。这个转换的过通常叫「**编译**」。

hello.c

```c
#include <studio.h>
int main() 
{
   printf("Hello World\n");
   return 0;
}
```

Linux下用GCC来编译Hello World程序

```shell
gcc hello.c # 编译代码，输出可执行文件
./hello # 可执行的二进制文件
# Hello World
```

编译的过程很复杂，分为4个步骤：**预处理**(Prepressing)、**编译**(Compliation)、**汇编**(Assertmbly)和**链接**(Linking)。
- （1）**预编译**：处理源代码中以“#”开始的预编译指令，比如“#include”、“define”等。
- （2）**编译**：把预处理完的文件进行词法分析、语法分析、语义分析及优化后生产成相应的汇编代码，这个过程是最复杂的。
- （3）**汇编**：将汇编代码转换成机器码，也就是上图的目标文件hello.o
- （4）**链接**：代码程序经常是由多个代码文件组成的，当每个文件都被汇编成“.o”文件时，需要一套机制将它们「组装」在一起，这个过程就叫做链接。
- ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fcc651436d3f47fb8627cb343ec6e8c5~tplv-k3u1fbpfcp-watermark.awebp)

站在CPU的视角来看看Hello World是如何被打印出来的。

### 连接-中转站和高速公路

首先编译好的文件是存在磁盘上的，得先加载到内存中。CPU通过总线和芯片打通了磁盘、内存之间的通信
- 问：为什么CPU不能直接读取磁盘的程序运行而要经过内存？
- 答：慢，缓慢的磁盘会影响我们程序执行的速度，因此需要更加快速、离CPU更近的存储，那就是内存。内存是一大块存储空间，可以存储很多数据信息
  - <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6454fd4ce5c499aad4c0050cbe4e46c~tplv-k3u1fbpfcp-watermark.awebp" width="50%" >
- 问：如何找到程序？
- 答：地址，每个字节在内存中都有一个地址，这样当CPU去内存中读程序时，只需要根据对应的地址就可以知道程序的具体内容。
  - <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b78698efab3f4f1a9f27c0a5f603f594~tplv-k3u1fbpfcp-watermark.awebp" width="50%" >
- 问：CPU是如何与内存、磁盘通信？
- 答：通过主板上的**总线**和**芯片组**，总线好理解，就像高速公路，数据信息可以通过这条高速公路传递到CPU中。电脑主板上芯片很多，这里说的主要是**南桥**芯片和**北桥**芯片。
  - **北桥**芯片：北桥负责高速设备和CPU之间的沟通，主要就是CPU和内存、显卡之间的通信，但是随着技术的迭代，主板上的北桥芯片已经被内置到了CPU里了。
  - **南桥**芯片：南桥负责低速设备和北桥之间的通信，主要负责I/O总线之间的通信，如USB、LAN、ATA、SATA、音频控制器、键盘控制器、实时时钟控制器、高级电源管理等
- 问：为什么CPU与高速设备、低速设备之间的通信需要这两个芯片？CPU自己不能干吗？
- 答：① 任务分工，如果把所有的任务都交给CPU来处理，CPU太忙；② 备份，如果南桥芯片坏了，可以直接更换南桥，而不用换掉整个CPU。
  - <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea5c8c14ce4c4244881e829ee77c6c6f~tplv-k3u1fbpfcp-watermark.awebp" width="80%" >

### CPU-最强大脑

CPU 全称是 Central Processing Unit，即**中央处理单元**，本质是一块超大规模的集成电路。从逻辑上来分，它的内部是由**寄存器**、**控制器**、**运算器**和**时钟**组成的，下面来解释下各个组成是干什么的。
- **寄存器**：CPU内部其实有很多类型的寄存器，我们只需了解寄存器就是暂存数据、指令等信息的，它的本质是临时存储，由于是直接集成在CPU内部，所以读写它们的速度很快，一般一个CPU内部会有20-100个寄存器，这里给大家列举下常用寄存器与其功能。
  - 累加寄存器：存储执行运算的数据和运算后的数据
  - 标志寄存器：存储运算处理后的CPU的状态
  - 程序计数器：存储下一条指令所在内存的地址
  - 基址寄存器：存储数据内存的起始地址
  - 变址寄存器：存储基址寄存器的相对地址
  - 通用寄存器：存储任意数据
  - 指令寄存器：存储指令，CPU内部使用，程序员无法通过程序对该寄存器进行读写操作
  - 栈寄存器：存储栈区域的起始地址
- **控制器**：控制器负责把数据读出或者写入寄存器，并根据指令的结果来控制计算机。
- **运算器**：从名字就可以猜出来，运算器的主要工作就是运算，运算从内存读入寄存器的值
- **时钟**：它并不是我们见的钟表概念，它代表了你的CPU的工作频率，频率越高说明你的CPU处理的速度越快，但是越快就会带来另一个问题：散热。
  - <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fba39fd3cbf04d888b8db4653d303dfd~tplv-k3u1fbpfcp-watermark.awebp" width="80%" >

CPU的大致工作流程如下：
- 在时钟信号到来的时候，就开始工作，通过控制器把内存的数据读到各个寄存器中，然后如果有计算相关的逻辑，就交给运算器。发现没有，CPU的工作其实挺简单的，本质就是不停的读指令、执行指令。
  
但是CPU是如何读到代码指令的，以及代码里面的if else、函数调用都是如何执行分支判断、函数跳转的？

示例：伪代码，有分支判断、有函数跳转。

```c
a = 1 #0x0010
b = 2 #0x0011
if a > b { #0x0012
 printf("%s","a") #0x0013
} else { 
 add(a,b) #0x0014
} 
printf("%s","end") #0x0017

func add(int a,int b) { #0x0020
  return a+b
}
```

执行过程：
- <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f1263709ee543209dc39bc23c7c83a3~tplv-k3u1fbpfcp-watermark.awebp" width="80%" >
- 首先每段程序都有个开始的地址0x0010，也就是CPU读取程序的入口
- 把a=1这个数字读入通用寄存器中，程序计数器（PC寄存器）自动加1，即指向下一条指令 0x0011
- 指令寄存器拿到程序计数器的指令地址，把b=2这个数字读入通用寄存器中，程序计数器（PC寄存器）自动加1，即指向下一条指令0x0012
- 指令寄存器发现此处是比较逻辑，会执行a-b，此时可能会有三个结果分别是大于0，等于0，小于0，然后把这个结果存到标志寄存器里
  - 知识点：经常说的是CPU是64位或者32位，其实也表示了标志寄存器的长度
  - <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e640e071a8484ae99404346020619936~tplv-k3u1fbpfcp-watermark.awebp" width="80%" >
- 很明显，a是小于b的，CPU根据标志寄存器的状态值应该跳转到else里面，注意这时程序计数器的值不是加1，而是设置成else的地址 0x0014，当执行到0x0015的时候，需要发生函数跳转，程序计数器会被设置成 0x0020，但是这里并不是简单的函数跳转（专业术语叫做call），因为在函数执行完毕之后，还要返回，也就是程序计数器需要从0x0020再变成0x0017。call执行的时候会把后续要执行的指令地址0x0017存到栈中。
- 当add函数执行完，会有个return，return的时候会把上一步骤存入栈中的地址0x0017写入程序计数器中
- 指令寄存器根据程序计数器当前的地址执行最后的打印（end），结束。

总结：
- **顺序执行**的指令代码，程序计数器会自动累加（当然不一定累加的是1），然后找到下一条要执行的指令。
- **分支判断**时，程序计数器不是简单的累加地址，需要地址的跳转。
- **函数调用**不仅仅需要跳转地址，还要把函数执行完毕之后要执行的地址存下来，方便折回继续执行。
- 其实还有个**循环执行**，也就是代码中的for、while之类的，这时程序计数器会不停的在某些地址之间来回切换。


## 字符编码

【2022-10-13】[字符，字节和编码](http://www.regexlab.com/zh/encoding.htm)

一个汉字究竟占多少个字节？

答案是：根据编码来决定
- ① 如果是UTF-8编码，则占用3个字节
- ② 如果是GBK编码，则占用2个字节
  - 汉字UTF-8是占用3-6个字节，不过绝大多数汉字是3个字节。
- ③ 一个英文，不论编码，都只占用1个字节

### 字符与编码的发展

从计算机对多国语言的支持角度看，大致可以分为三个阶段：

| 阶段| 系统内码 |	说明 |	系统|
|---|---|---|---|
| 阶段一 | ASCII	| 计算机刚开始只支持英语，其它语言不能够在计算机上存储和显示。	| 英文 DOS |
| 阶段二 | ANSI编码（本地化）| 为使计算机支持更多语言，通常使用 0x80~0xFF 范围的 2 个字节来表示 1 个字符。比如：汉字 '中' 在中文操作系统中，使用 \[0xD6,0xD0\] 这两个字节存储。<br>不同的国家和地区制定了不同的标准，由此产生了 GB2312, BIG5, JIS 等各自的编码标准。这些使用 2 个字节来代表一个字符的各种汉字延伸编码方式，称为 ANSI 编码。在简体中文系统下，ANSI 编码代表 GB2312 编码，在日文操作系统下，ANSI 编码代表 JIS 编码。<br>不同 ANSI 编码之间互不兼容，当信息在国际间交流时，无法将属于两种语言的文字，存储在同一段 ANSI 编码的文本中。| 	中文 DOS，中文 Windows 95/98，日文 Windows 95/98 |
| 阶段三 | UNICODE（国际化）|	为了使国际间信息交流更加方便，国际组织制定了 UNICODE 字符集，为各种语言中的每一个字符设定了统一并且唯一的数字编号，以满足跨语言、跨平台进行文本转换、处理的要求。| 	Windows NT/2000/XP，Linux，Java |

### 字符串的内存存放

字符串在内存中的存放方法

在 ASCII 阶段，**单字节**字符串使用一个字节存放一个字符（SBCS）。比如，"Bob123" 在内存中为：
- 42	6F	62	31	32	33	00
- B 	o  	b  	1 	2  	3 	\0

在使用 ANSI 编码支持多种语言阶段，每个字符使用一个字节或多个字节来表示（MBCS），因此，这种方式存放的字符也被称作多字节字符。比如，"中文123" 在中文 Windows 95 内存中为7个字节，每个汉字占2个字节，每个英文和数字字符占1个字节：
- D6	D0	CE	C4	31	32	33	00
-   中     	文	   1	 2	 3	 \0

在 UNICODE 被采用之后，计算机存放字符串时，改为存放每个字符在 UNICODE 字符集中的序号。目前计算机一般使用 2 个字节（16 位）来存放一个序号（DBCS），因此，这种方式存放的字符也被称作宽字节字符。比如，字符串 "中文123" 在 Windows 2000 下，内存中实际存放的是 5 个序号：
- 2D	4E	87	65	31	00	32	00	33	00	00	00	← 在 x86 CPU 中，低字节在前
-   中	     文	     1	     2	     3	     \0	　

一共占 10 个字节。

### 字符，字节，字符串

理解编码的关键，是要把字符的概念和字节的概念理解准确。这两个概念容易混淆，我们在此做一下区分：

|　概念 |	概念描述 |	举例 |
|---|---|---|
| 字符	| 人们使用的记号，抽象意义上的一个符号。 |	'1', '中', 'a', '$', '￥', …… |
| 字节	| 计算机中存储数据的单元，一个8位的二进制数，是一个很具体的存储空间。| 0x01, 0x45, 0xFA, …… |
|ANSI字符串|	在内存中，如果“字符”是以 ANSI 编码形式存在的，一个字符可能使用一个字节或多个字节来表示，那么我们称这种字符串为 ANSI 字符串或者多字节字符串。 | 	"中文123"（占7字节） |
| UNICODE字符串|	在内存中，如果“字符”是以在 UNICODE 中的序号存在的，那么我们称这种字符串为 UNICODE 字符串或者宽字节字符串。|	L"中文123"
（占10字节）|

由于不同 ANSI 编码所规定的标准是不相同的，因此，对于一个给定的多字节字符串，我们必须知道它采用的是哪一种编码规则，才能够知道它包含了哪些“字符”。而对于 UNICODE 字符串来说，不管在什么环境下，它所代表的“字符”内容总是不变的。


### 字符集与编码

各个国家和地区所制定的不同 ANSI 编码标准中，都只规定了各自语言所需的“字符”。比如：汉字标准（GB2312）中没有规定韩国语字符怎样存储。这些 ANSI 编码标准所规定的内容包含两层含义：
- 使用哪些字符。也就是说哪些汉字，字母和符号会被收入标准中。所包含“字符”的集合就叫做“字符集”。
- 规定每个“字符”分别用一个字节还是多个字节存储，用哪些字节来存储，这个规定就叫做“编码”。

各个国家和地区在制定编码标准的时候，“字符的集合”和“编码”一般都是同时制定的。因此，平常我们所说的“字符集”，比如：GB2312, GBK, JIS 等，除了有“字符的集合”这层含义外，同时也包含了“编码”的含义。

“UNICODE 字符集”包含了各种语言中使用到的所有“字符”。用来给 UNICODE 字符集编码的标准有很多种，比如：UTF-8, UTF-7, UTF-16, UnicodeLittle, UnicodeBig 等。

### 常用编码

简单介绍一下常用的编码规则，为后边的章节做一个准备。在这里，我们根据编码规则的特点，把所有的编码分成三类：

| 分类 |	编码标准	| 说明 |
|---|---|---|
| 单字节字符编码 | ISO-8859-1	| 最简单的编码规则，每一个字节直接作为一个 UNICODE 字符。比如，[0xD6, 0xD0] 这两个字节，通过 iso-8859-1 转化为字符串时，将直接得到 [0x00D6, 0x00D0] 两个 UNICODE 字符，即 "ÖÐ"。<br>反之，将 UNICODE 字符串通过 iso-8859-1 转化为字节串时，只能正常转化 0~255 范围的字符。|
| ANSI 编码	GB2312,BIG5,Shift_JIS,ISO-8859-2 ……	| 把 UNICODE 字符串通过 ANSI 编码转化为“字节串”时，根据各自编码的规定，一个 UNICODE 字符可能转化成一个字节或多个字节。<br>反之，将字节串转化成字符串时，也可能多个字节转化成一个字符。比如，[0xD6, 0xD0] 这两个字节，通过 GB2312 转化为字符串时，将得到 \[0x4E2D\] 一个字符，即 '中' 字。<br>“ANSI 编码”的特点：<br>1. 这些“ANSI 编码标准”都只能处理各自语言范围之内的 UNICODE 字符。<br>2. “UNICODE 字符”与“转换出来的字节”之间的关系是人为规定的。|
| UNICODE 编码 |	UTF-8,UTF-16, UnicodeBig ……	| 与“ANSI 编码”类似的，把字符串通过 UNICODE 编码转化成“字节串”时，一个 UNICODE 字符可能转化成一个字节或多个字节。<br>与“ANSI 编码”不同的是：<br>1. 这些“UNICODE 编码”能够处理所有的 UNICODE 字符。<br>2. “UNICODE 字符”与“转换出来的字节”之间是可以通过计算得到的。|

实际上没有必要去深究每一种编码具体把某一个字符编码成了哪几个字节，我们只需要知道“编码”的概念就是把“字符”转化成“字节”就可以了。对于“UNICODE 编码”，由于它们是可以通过计算得到的，因此，在特殊的场合，我们可以去了解某一种“UNICODE 编码”是怎样的规则。

[字符编码详解——彻底理解掌握编码知识，“乱码”不复存在](https://blog.51cto.com/polaris/377468)

# 其它

## 少儿编程

- 【2021-3-14】[Python太低级，我选 C++？码农带你揭穿少儿编程的骗局](https://www.toutiao.com/i6921532950840476174)
- 少儿编程该怎样入门?
- 从我个人经验来说，学好编程只需要两个条件：
  - 带着目标学习
  - 一个字一个字亲手写代码
- 学习编程其实是一个非常庞大的过程，你需要学完编程语言、标准库、常用第三方库、网络协议、数据库、操作系统、数据结构、常用算法等一大堆内容，才能真正做一个产品级的程序。但是对于少儿编程来说，学好编程语言本身，一点点标准库和第三方库，也可以做出一些好玩的程序。
- 对于娃是否应该学习编程这件事情，如果中高考不考，可以完全不用学。Tony 老师往往告诉你学习编程，可以训练小朋友逻辑思维，让小朋友数学更好。但真相却恰恰相反，是逻辑思维好的小朋友，学编程更容易而已。
- 编程语言中用到的数学逻辑只有 3 个:
  - 条件判断
  - 循环
  - 递归
- 所以入门编程，你最需要的是给娃定一个目标，让他能带着任务学习，比如编写一个小小的游戏，或者让机器人跑起来。有了目标，就可以按照下图一步一步开始学习：
  - ![](https://p3-tt.byteimg.com/origin/pgc-image/aee41b60a1f143369f9dcef63f083be7?from=pc)
- 解释
  - 学完蓝色部分，基本什么也做不了，但是对编程本身会有非常清晰的概念，大部分娃学到这里也就结束了。
  - 学完橙色部分，就可以实现有趣的小游戏，或者让机器人随心所欲跑来跑去，娃会有满满的乐趣和成就感。
  - 绿色和紫色部分，预留给走专业路线的娃，如果上了高中依然热爱编程，并且有剩余精力，可以开始学习这两部分内容。不过即使学完紫色部分，也不代表编程就学完了
- 展示一下专业码农的[路线图](https://p3-tt.byteimg.com/origin/pgc-image/7eb17b3f555a44babf724f1283de9fb4?from=pc)，英文原版图谱:[前端知识图谱](https://roadmap.sh/frontend),[后端知识图谱](https://roadmap.sh/backend):
  - ![](https://p3-tt.byteimg.com/origin/pgc-image/7eb17b3f555a44babf724f1283de9fb4?from=pc)
  - 学完这些，才能差不多找一份互联网中级码农的工作，而且职业生涯还比较艰辛。行业变化特别快，技术天天都更新，工资全是加班费，年轻人便宜还玩命。
- 总结
  - 不要让娃从 C++ 入门编程，这样只会加速娃放弃学习
  - 学习编程不会提高娃的数学成绩，也不会提高逻辑思维能力
  - 绝大部分娃最终都会放弃，不要对娃有太高的期许，保留乐趣最重要
  - 如果娃有兴趣，坐得住，老师靠谱，可以从 Python 入门编程


# 结束
