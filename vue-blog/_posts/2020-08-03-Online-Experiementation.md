---
layout: post
title:  "服务部署及在线实验笔记-online-experimentation"
date:   2020-08-03 18:22:00
categories: 技术工具 数学基础
tags: A/B实验 假设检验 因果推理 灰度发布 nginx 平滑发布 金丝雀 反向代理 interleaving 统计 偏差 谬误 测试 k8s docker
excerpt: 互联网公司常用的服务部署、在线实验方法讲解
author: 鹤啸九天
mathjax: true
---

* content
{:toc}

# 总结

- [Innovating Faster on Personalization Algorithms at Netflix Using Interleaving](https://medium.com/netflix-techblog/interleaving-in-online-experiments-at-netflix-a04ee392ec55)，中文版本：[Netflix推荐系统(Part Seven)-改善实验系统](https://blog.csdn.net/wqw547243068/article/details/107783748)

![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC85LzMwLzE2NjI4NDM3Mzg3Y2RlNjg?x-oss-process=image/format,png)

![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC85LzMwLzE2NjI4NGJjMjU2MWI0ZWI?x-oss-process=image/format,png)


# 数学知识

## 什么是显著性检验

- “`显著性检验`”的英文名称是“significance test”。在统计学中，显著性检验是“**统计假设检验**”(Statistical hypothesis tesing)的一种，显著性检验是检测科学实验中的<font color='blue'>实验组与对照组之间是否存在差异及差异是否显著</font>的办法。
- “统计假设检验”指出了“显著性检验”的前提条件是“统计假设”，换言之“无假设，不检验”。任何人在使用显著性检验之前必须知道假设是什么。
- 一般而言，把要检验的假设称之为`原假设`，记为H0，把与H0相对应的假设称之为`备择假设`，记为H1。
    - 第一类错误-**弃真**（α）：如果原假设为真，而检验的结论却劝你放弃原假设，称为**第一类错误**，出现的概率记为α。
    - 第二类错误-**存伪**（β）：如果原假设不为真，而检验的结论却劝你接受原假设，称为**第二类错误**，出现的概率记为β。
- 通常只限定犯第一类错误的最大概率α， 不考虑犯第二类错误的概率β。这样的假设检验称为`显著性检验`，概率α称为`显著性水平`。
- 显著性水平是数学界约定俗成的，一般有α =0.05,0.025.0.01这三种情况。代表着显著性检验的结论错误率必须低于5%或2.5%或1%（统计学中，通常把在现实世界中发生几率小于5%的事件称之为“**不可能事件**”）（问：不是小概率事件吗？）。

## 什么是卡方检验

- 卡方检验(Chi-Square Test)在大数据技术场景中，通常用来检验某个变量或特征是不是**和应变量有显著关系**。
- 如：观察性别和在线买不买生鲜食品有没有关系。
    - ![](https://math.jianshu.com/math?formula=X%5E%7B2%7D%3D%5CSigma%20%5Cfrac%7B(observed-expected)%5E2%7D%7Bexpected%7D)

## 假设检验基本理论
-------

- 参考：[用Python如何实现“假设检验”](https://zhuanlan.zhihu.com/p/50190968)

![](https://pic4.zhimg.com/80/v2-f9031f3a6fe3328584e9df11d4b93fd5_720w.jpg?source=1940ef5c)

假设检验现实生活实例可参考 [假设检验的逻辑是什么？](https://www.zhihu.com/collection/288499050)
 
1. 先确定原假设（零假设）和备则假设
    - 原假设（H0）：某个断言
    - 备则假设（H1）：原假设对立的断言
2. 假设检验实际是对假设检验的断言进行试验，你对假设保持怀疑，随后如果有足够的拒绝证据，则拒绝；
3. 假设检验无法给出绝对的证明，假定原假设为真的前提下，通过假设检验了解结果到底有多可靠。如果结果极不可能发生，就会成为证明原假设为假的证据
4. 基本概念：
    * 检验统计量：用于对假设进行检验的统计量  
    * 显著性水平：用 α 表示， 表明希望在观察结果的不可能程度达到多大时，拒绝H0;

P(X<c) < α 其中X为检验统计量，c为临界值，α为显著性水平。
 
如果α=5%，表示如果样本中的检验中的检验统计量落在概率分布的最低5%范围内，将否定断言（原假设H0）
 
![](https://pic4.zhimg.com/80/v2-1ebfdc371235086068e7aa6eff21c2ee_720w.jpg)
 
* P值：某个小于或者等于拒绝域方向上的一个样本数值的概率；它是取得样本中的各种结果或者取得拒绝域方向上的某些更为极端的结果的概率；P值是在假定原假设为真时，得到与样本相同或者更极端的结果的概率。
    
- 如果P只位于拒绝域中，则拒绝H0；
- 如果P只位于拒绝域外，则没有充足证据，那么接受H0
 
5. 假设检验分类：（主要通过备则假设判断）
    * 单尾检验：拒绝域落在数据集一侧

* 如果H1是 '<' 符号 左尾 此时拒绝域位于数据的低端
 
![](https://pic2.zhimg.com/80/v2-ad9cf12c11e5f550bb87ae4603565b81_720w.jpg)
 
* 如果H1是 '>' 符号 右尾
 
![](https://pic4.zhimg.com/80/v2-e3c2a7f4d5b37110c6b633ecec8f2d7b_720w.jpg)
 
举例：某制药公司断言，某款药品针对某种病治愈率为90%患者，那么
- 原假设H0：P=0.9
- 备则假设H1: P<0.9
 
这就是左尾检验

无论是左尾检验还是右尾检验，P<α 即拒绝H0。 
*   双尾检验：拒绝域一分为而于数据集两侧

如果H1是 '≠' 符号 双尾
 
![](https://picb.zhimg.com/80/v2-d56ae1398ef74e216da2ba3e66896801_720w.jpg)
 
如果备则假设H1≠0.9， 则我们应使用双尾检验，我们应该查看检验统计量是否显著多于90%或者显著少于90%。
 
![](https://pic3.zhimg.com/80/v2-4bc25346eee2a7f31cda02149622543d_720w.jpg)
 
6. 几个概念的区别

* 置信区间：代表“总体参数位于两个极限之间”这一结果的具有的可信程度  
* 置信水平：总体参数位于置信区间的概率
* 显著性水平：反映数值位于某个极限以外的概率，一般为5%
 
显著性水平越小，则证据力度越大；为了拒绝H0，样本结果需要达到的不可能程度越高。

7. 假设检验六个步骤：

*   确定进行检验的假设（H0, H1）    
*   选择检验统计量
*   确定拒绝域
*   求出检验统计量的P值
*   查看样本结果是否位于拒绝域为
*   做出决策


# A/B实验

- 名言
    - 不是每个想法都是好的，大部分想法都是不好的。
    - Many times，we have to tell people that their new beautiful baby is actually…ugly。
- 在互联网背景下，快速试错已经成为产品持续迭代的必备能力。借鉴传统行业(医学等)成熟的实验理论(因果推断)，互联网逐渐发展了以AB Test为核心的数据驱动决策之路。在以下场景中可以考虑使用A/B Test:
    - 重大产品功能很难决策，不确定哪个方案效果最优。
    - "后验"成本高，如果改版失败，业务风险较大。
- 通过 abtest 系统对迭代方案进行实验, 并结合数据进行分析，反向再验证和驱动方案，是一个发现问题、提出假设、印证猜想、不断优化的过程
    - ![](https://pic1.zhimg.com/80/v2-f5104c5a1a06e7b6feeb97a8e2cece98_1440w.jpg)

## 因果推断

- 因果推断(Causal Inference)是指在一种现象已经发生的情况下推出因果关系结论的过程。比如说全球气候变暖，需要分析是什么因素导致的，各个因素对全球气候变暖影响有多大。
- 因果推断要做的是识别因果关系，量化因果作用。而这也是A/B测试要做的事情，即根据实验结果判断新版(B)相比原版(A)有无显著提升，如果有，提升了多少。
- 上面提到了因果关系，所谓因果关系(causality或causation)，是一个事件(即"因")和第二个事件(即"果") 之间的作用关系，其中后一事件被认为是前一事件的结果。一般来说，一个事件是很多原因综合产生的结果，而且原因都发生在较早时间点，而该事件又可以成为其他事件的原因。
- 因果关系举例:
    - 1). 睡得晚(因)，长黑眼圈(果)。
    - 2). 如果水温达到100度(因)，水会沸腾(果)。
    - 3). 长时间看电视(因)，影响孩子视力(果)。
- 因果关系的结构可表示成顺序的因果逻辑：
    - 因为事件A(前提:事件A已经发生)，所以事件B(结论:事件B将要发生)
- 注意：相关 ≠ 因果
- 机器学习算法更加关注特征之间的相关性，而无法识别特征之间的因果性，而很多时候在做决策与判断的时候，我们需要的是因果性。分析因果关系的目的是通过改变"因"，从而对真实世界做出改变("果")，这也是与相关关系最大不同。
- 传统的因果推断思想中，从因到果是一个封闭的系统。人们往往采用"控制"的方法，将影响结果的所有其他因素控制住，仅让关心的变量变化，这样结果的变化就是"关心的变量"造成的影响。随机化实验方法就是"控制"其他变量不变的常用手段，因此随机化试验是因果推断的黄金法则，而A/B Test恰好是随机化试验在互联网的应用。
- 机器学习大多数情况下仅作为一种可以拟合数据的特别函数f(x)[p(y\|x)]，近年来将机器学习方法应用到因果推理[p(y\|do(x))]逐渐成为研究热点，图林获奖者获奖得者Judea Pearl(另一作者Dana Mackenzie)的新书，《The Book of Why: The New Science of Cause and Effect》，将因果推断带入大家视野。

## 什么是A/B测试

- A/B Test是一个系统工程，互联网实际应用中多参考Google的分层实验模型《Overlapping Experiment Infrastructure: More, Better, Faster Experimentation》
    - 不同域之间共享100%流量，如上域1分流30%，域2分流70%。
    - 同一个域的不同层之间，会重复使用这个域中的流量，且每次各层进入流量会重新打散，保证互相不影响。
    - ![](https://pic3.zhimg.com/80/v2-07923499443ab75805dc0d06e5f35e16_720w.jpg)
- 完整的A/B Test是一个**衡量->发现->迭代->验证**的持续循环过程，除去基本的分流和实验管理功能外，A/B Test还应该包括**实验数据收集**和**实验数据分析**功能，系统流程
    - AB实验配置平台：产品经理/研发配置新实验。
    - 分流服务：读取AB实验配置平台的配置数据，执行具体分流算法。
    - 集成方应用：客户端上报实验分组和埋点(实验数据回收)。
    - 数据分析：分析打点数据，生成报表数据。
    - AB实验展示平台：实验数据可视化，用于辅助决策。
    - ![](https://pic3.zhimg.com/80/v2-7ce5932a82c8ee6d972372e18b7b8d26_720w.jpg)

- A/B测试是一种用于提升App/H5/小程序产品转化率、优化获客成本的数据决策方法。

![](https://pic1.zhimg.com/80/v2-11077994efe44dbf82e6512608dd2260_720w.jpg)

## A/B的意义

- 基于A/B测试的灰度发布更重要的不是优化，而是保护性发布，先通过小流量的实际用户测试，有BUG或者新版本体验不好，可以立即回滚到老版本，简单有效。
- ![](https://pic4.zhimg.com/80/72cdd3a4d3bba3ba4a4f0be795be831f_720w.jpg?source=1940ef5c)
- ![](https://pic2.zhimg.com/80/v2-313699ae4192816761bdcb7301c62112_720w.jpg?source=1940ef5c)

分析用户行为时，常常会产生两个错误——“辛普森悖论”和“幸存者偏差”

[7种经典的统计学谬论](https://blog.csdn.net/weixin_41961559/article/details/106091494)



### 辛普森悖论 Simpson's Pradox

- **辛普森悖论**（Simpson's Paradox）亦有人译为**辛普森诡论**，为英国统计学家E.H.辛普森（E.H.Simpson）于1951年提出的悖论，在某个条件下的两组数据，分别讨论时都会满足某种性质，可是一旦合并考虑，却可能导致相反的结论。
- 正式定义：<font color='red'>辛普森悖论是指数据集分组呈现的趋势与数据集聚合呈现的趋势相反的现象。</font>
- 示例：Sophia和Carlo两家餐厅推荐指数，可以通过看男性和女性各组的评分，也可以看整体的评分
  - ![](https://img-blog.csdnimg.cn/20200513100330135.png)
  - 推断：Carlo’s 在男性和女性推荐率上都**赢**了，但却**输**在了总体推荐率上！
  - 原因：只查看单独各组数据的百分比会忽略掉样本的大小，也就是评论者的人数。每个百分比都由推荐用户数与相对应的评论人数计算得到。Carlo’s 有更多的男性评论者，而Sophia’s 有更多的女性评论者，因此导致了矛盾的结果。
- 辛普森悖论的另一个现象：**分组**数据表现的相关性方向与**整体**数据表现的相关性方向截然**相反**。

如何避免？
- 不能简单的将分组数据汇总相**加**，而要仔细观察分组数据的特征。
- 为避免辛普森悖论出现，就需要斟酌个别分组的权重，以一定的**系数**去消除以分组资料基数差异所造成的影响，同时必须了解该情境是否存在其他潜在因素而综合考虑。

辛普森悖论揭示了**看到的数据并非全貌**。我们不能满足于展示的数字或图表，要考虑整个数据**生成过程**，考虑**因果模型**。一旦理解了数据产生的机制，就能从图表之外的角度来考虑问题，找到其它影响因素。

### 幸存者偏差

幸存者偏差也称“生存者偏差”或“存活者偏差”，是一种常见的逻辑谬误。指的是当取得资讯的渠道仅来自于幸存者时，因为只能看到经过某种筛选而产生的结果，而没有意识到筛选的过程，因此忽略了被筛选掉的关键信息，此资讯可能会存在与实际情况不同的偏差。
- "幸存者偏差”：经过某种**筛选**而产生的结果，但没有意识到筛选的过程，因此忽略了被筛选掉的关键信息，进而得出错误的结论。
- 在“沉默的数据”、“死人不会说话”等等日常表达中，涉及幸存者偏差。此规律也适用于金融和商业领域，存活下来的企业往往被视为“传奇”，它们的做法被争相效仿，但其实有些也许只是因为偶然原因幸存下来了而已。

举例
- 在二战期间，人们发现幸存的轰炸机中，机翼中弹的数量很多，而机身中弹的却很少。因此认为应该加固飞机机翼，其实不然，就是因为机翼中弹多还能飞回来，所以机翼中弹并没有影响飞机返航；而机身中弹的少则说明了子弹打中机身对飞机的影响更大，导致飞机不能返航，在这个飞机问题中，只统计到了幸存下来的飞机，以此下结论，是不正确的。
  - ![](https://img-blog.csdnimg.cn/20191023101736246.jpg)
- 现实生活中也有很多幸存者偏差的案例，比如感觉周围都是本科以上的人，而实际上中国具备本科以上学历的人，只占总人口的**3%**。
- 为什么感觉知乎上应届生人人都是月薪过万，因为你看到的都是月薪过万的人在答题，**月薪低于1万的都处于沉默状态**。
- 再比如媒体调查“喝葡萄酒的人长寿”。一般是调查了那些长寿的老人,发现其中很多饮用葡萄酒。但还有更多**经常饮用葡萄酒但不长寿的人已经死了**,媒体根本不可能调查到他们。
- 回到投资领域,在投资理财类电视节目中,经常看到取得成功的投资者谈论其投资经验和方法,但观众往往会忽略了一个事实:**采用同样经验和方法而投资失败的人是没有机会上电视的**。

幸存者偏差现象可能导致以下的结果:
- (1) 投资成功者出书出名,失败者将默默无闻,导致电视上大量专家在传经布道、市面上充斥着太多投资成功学类的书籍,可能会让观众或读者高估了通过投资获得成功的概率;
- (2) 由于条件限制或者心理因素,投资成功者难以保证理性和客观,容易夸大自己能力、忽略运气因素、弱化当时所承担的风险等。

如何避免
- 应对幸存者偏差的办法是**双盲**实验设计和详细全面客观的**数据纪录**，即“兼听则明”，抛掉对个案的迷信，全面系统的了解才能克服这个偏差。
- 对于如何消除幸存者偏差的误区,没有好的办法,但如果能做到以下几点,应该有些好处：
  - （1）在投资领域,我们改变不了生存者偏差现象的存在,但可以努力**不盲从**所谓的权威；
  - （2）对于基金、私募以及个人投资者的能力评价,要看**长期**的、最好是跨越多个经济周期的业绩记录；
  - （3）为了使样本更反映事实,更应该搜集介绍投资失败的案例和总结,不但要向成功的人学习如何成功,更要从失败的人那里总结为什么失败,因为投资很大程度上是个避免失败的过程。

### 基本比率谬误 Base Rate Fallacy

**基本比率谬误**（base rate fallacy）是指对统计学上的忽略基本**比率**而导致的推论谬误。

问题：买矿泉水的人多呢，还是买香奈儿香水的人多？
- 人群和需求概率明摆着，简直不是问题。但是人们往往会通过代表性来评估概率，忽视基本比率。代表性的意思是，通过比较 B 与 A 的相似程度来评估概率。例如，如果 A 能高度代表 B，人们就会认为 A 源自 B 的概率高。但如果 A 与 B 并不相似，人们就会认为 A 源自 B 的概率低。
  - ![img](https://img-blog.csdnimg.cn/2020051310222840.png)

经典问题：Jack 已经退休。那么他是图书馆员还是推销员？
- 需要考虑实际中推销员的比例远远大于图书馆员，而不能简单凭“退休”二字推测大概率为图书馆员。

根据美国的统计数据，一个40岁左右的女性患乳腺癌的概率大约为1%。如果她通过乳房影像学检查来测试自己是否患乳腺癌，被误诊患上乳腺癌的概率约为9%。那么问题来了：如果一位40岁的女性去做了乳房影像学检查，结果显示她患上乳腺癌。她真正患上乳腺癌的概率是多少？是91%吗？
- 回答91%的朋友，恭喜你犯了基本比率谬误（base rate fallacy），即忽略了基本比率导致的推论谬误。我们假设对1000人进行检查，根据下图计算结果可知，正确答案约为9%。由于患上乳腺癌的女性的基本比率本来就很小，加上乳房影像检查自身带有的误诊率，其实只有9%左右的人真的患上了乳腺癌。
  - ![img](https://img-blog.csdnimg.cn/2020051310403415.png)

假设同性恋染上 G 病的概率是异性恋的 9 倍，张三染上了 G 病，而我们对他的性取向一无所知。试问张三是同性恋的概率是多少？
- 如果回答 90%，恭喜你又犯了基本比率谬误。事实上，如果我们不清楚同性恋和异性恋占整个群体的比率（即基本比率），就**无法回答**这个问题。
- 为方便起见，我们假定群体有 100 人，同性恋有 10 人（占 1/10 ），异性恋有 90 人（占 9/10 ）。再假设异性恋染上 G 病的概率是 X，则同性恋染上 G 病的概率为 9X。我们可用下表表示各子群体的分布
  - ![](https://img-blog.csdnimg.cn/20200513102957909.png)
  - 张三是同性恋的概率是
    - ![](https://img-blog.csdnimg.cn/2020051310301011.png)
- 来自直觉的概率判断（9/10），只有在同性恋与异性恋比例相等时才适用。假定群体有100人，同性恋、异性恋各50人，则可用下表表示各种子群体的分布
  - ![](https://img-blog.csdnimg.cn/20200513103031335.png)
  - 张三是同性恋的概率是 90%
    - ![](https://img-blog.csdnimg.cn/20200513103102663.png)

如何避免？
- 做出任何判断前，首先需要对基本比率有个大致的认识，否则很容易不小心就陷入统计的陷阱

### 区群谬误

- 区群谬误（Ecological fallacy），又称生态谬误，层次谬误，是一种在分析统计资料时常犯的错误。和以偏概全相反，区群谬误是一种以全概偏，如果仅基于群体的统计数据就对其下属的个体性质作出推论，就是犯上区群谬误。这谬误假设了群体中的所有个体都有群体的性质(因此塑型(Sterotypes)也可能犯上区群谬误)。区群谬误的相反情况为化约主义（Reductionism)。


### 伯克森悖论 Berkson's Paradox

- 定义：伯克森悖论指两个本来**无关**的变量之间体现出貌似强烈的**相关**关系

示例
- 为什么很多人会觉得帅哥都是混蛋？做个简化的假设，当你找男生约会的时候最看重两个条件：长得是不是帅，对你是不是好。两者至少满足其一你才会考虑跟他约会，长得不帅的渣男压根没有机会。因此对你所有的约会对象而言，两者有了负相关，于是你可能产生出渣男长得帅、暖男长得丑的印象。
- 同样的，演员的演技和长相成反比、学生文化课成绩和体育课成绩成反比也是伯克森悖论的例子

如何避免？
- 考虑变量本身之间是否存在关系或忽略了部分样本

### 罗杰斯现象 Will Rogers Phenomenon

- 罗杰斯现象，又称Will Rogers悖论，是指将某些事物从一个组移到另一个组，两组的平均值增大，虽然其中没有值变大。
- 因为当数据点从一个组重新归类到另一组的时候，如果这个点在原来组的平均线以下，但是在新组的平均线之上，那么这两个组的平均线都会提升。
- 这一悖论源于美国喜剧演员Will Rogers。他曾经开玩笑说，“当俄克流民离开俄克拉荷马州并且搬到加尼福尼亚州，他们同时提升了两个州的平均智力水平。”

举例说明
- 假设有6个人，分别为40、50、60、70、80、和90岁。现在将他们分为两组。第一组包括40岁和50岁的两人，因此组平均年龄为45岁。剩下的归入第二组，因此组平均年龄为75岁。
  - ![](https://img-blog.csdnimg.cn/20200513104229742.png)
- 现在把第二组中的那位60岁的哥们，移去第一组。移过去以后，第一组的平均年龄变为50岁，而第二组的平均年龄变为80岁。两组的平均年龄都上升了。

罗杰斯现象，导致我们在医学领域产生一些容易让人混淆的，似是而非的结论。
- 前列腺特异抗原测试（PSA测试）可以帮助我们诊断前列腺癌。在没有发明这项测试前，很多人患了前列腺癌却不自知，因此他们被归入“健康”人群。而那些被确诊前列腺癌的患者，被归入“患者”人群。
- 有了PSA测试这项技术以后，很多人在年纪轻轻时也能通过该测试确诊自己是否患上前列腺癌。这部分人，就被移出“健康”人群，归入“患者”人群。
- 由于这个归类的变化，导致患上前列腺癌的“患者”人群，以及“健康”人群的平均寿命都得到了提高。因为“健康”人群中被移去一部分癌症患者，而这些癌症患者属于“轻度病患”（前列腺癌的致死率很低），因此“健康”和“患者”两个人群的寿命平均值均得到了提升，让人误以为PSA测试能够帮助我们延长寿命。

如何避免
- 需考虑平均值变大的根本原因，斟酌两次计算平均值前后分组之间的变化。

### 赌徒谬论 Gambler's Fallacy

- 定义：**赌徒谬误**（Gambler’s Fallacy）亦称为**蒙地卡罗谬误**，是一种错误的信念，以为随机序列中一个事件发生的机会率与之前发生的事件有关，即<font color='blue'>事件发生的机会率会随着之前没有发生该事件的次数而上升。</font>
  - 如重复抛一个公平硬币，而连续多次抛出反面朝上，赌徒可能错误地认为，下一次抛出正面的机会会较大

赌徒谬误是生活中常见的一种不合逻辑的推理方式，认为一系列事件的结果都在某种程度上隐含了**自相关**的关系，即: 如果事件A的结果影响到事件B，那么就说B是“依赖”于A的。
- 例如，一晚上手气不好的赌徒总认为再过几把之后就会风水轮流转，幸运降临。
- 相反的例子，连续的好天气让人担心周末会下起大雨。

赌徒谬误亦指相信某一个特定的结果由于最近已发生了（“运气用尽了”）或最近没有发生（“交霉运”），再发生的机会会较低。
- 比如一个赌徒在打赌硬币是正面朝上或是背面朝上时的情景，前面5次的结果都是正面朝上，那么下一次他觉得反面朝上的概率会更大，这就是赌徒谬论。
- 为什么说是谬论呢？因为高中时就学过扔硬币这个问题的概率，每扔一次一枚硬币是一个独立的事件，正面朝上和反面朝上的概率相同都是0.5，不受前面扔了多少次的影响，也就是说虽然前面5次都是正常朝上，下一次仍是正面朝上的概率也还是0.5。

聊到这，可能有些人会不理解了，或者脑海里依稀记得好像老师讲过，扔一枚硬币扔个1000次，正面朝上和反面朝上的次数都是接近一半的呀，能想到这里的同学，恭喜你，已经入门了。确实如此，但请看清楚前提：扔1000次，这就是**大数定理**，当我们大量重复某一相同实验时，最后的结果会稳定在某一数值附近，但把大量重复事件的规律运用在**少数**的事情上就错了。

如何避免
- 赌徒谬误的产生是因为人们错误的诠释了“**大数法则**”的平均律。投资者倾向于认为大数法则适用于大样本的同时，也适用于**小样本**。Tversky and Kahneman把赌徒谬误戏称为“**小数法则**”（law of small numbers）。
- 一个独立的事件并不会受前一个独立事件结果的影响。
- 大数定理不能用于单个独立事件。


### 生日悖论 Birthday Paradox

假设你的班上一共有23位同学，其中任何两位同学生日撞期的概率为多少？
- 有人可能会这么想：一年有365天，把这23位同学分布在365天里，撞期的概率应该很小。大概不到10%吧。
- 事实上，23位同学中，生日撞期的概率为1/2。就是说，有一半的概率，这个班上至少有一对同学的生日相同。
- 算一下23位同学生日不撞期的概率。然后用1减去那个数字，就是这些同学生日撞期的概率。假设23位同学排队逐个进入教室。第一个进入教室的同学，其生日和其他同学不一样的概率为1。第二位同学，其生日和其他同学不一样的概率为364/365。第三位同学，其生日和前面两位同学生日不一样的概率为363/365。以此类推，所有同学生日不撞期的概率 = 1 * 364/365 * 363/365 … 然后用1减去上面的乘积，可以得出，p(n) = 1 - 365!/(365^n*(365-n)!)当教室里有23个同学时，其结果为0.5左右。
- ![](https://img-blog.csdnimg.cn/20200513110233523.png)


- **生日悖论**（Birthday paradox）是指，如果一个房间里有23个或23个以上的人，那么至少有两个人的生日相同的概率要大于50%。这就意味着在一个典型的标准小学班级(30人)中，存在两人生日相同的可能性更高。对于60或者更多的人，这种概率要大于99%。从引起逻辑矛盾的角度来说生日悖论并不是一种悖论，从这个数学事实与一般直觉相抵触的意义上，它才称得上是一个悖论。大多数人会认为，23人中有2人生日相同的概率应该远远小于50%。
- 计算与此相关的概率被称为**生日问题**，在这个问题之后的数学理论已被用于设计著名的密码攻击方法：**生日攻击**。

如何避免
- 以概率为依据做决策是不合逻辑的，然而逻辑和统计本身却是大不相同
  - 在逻辑上，一个命题只有对和错两种划分
  - 而在统计上，却可以说成对的概率有50%，错的概率为20%
- 就是这一点不确定性造就了以逻辑推理和统计为基础所得决策上的不一致，或者说矛盾，这就是**统计**关系不等于**因果**关系。



### 解决

- 很多的测试行为并不科学，特别是很多定向的用户测试经常会有这个弊端
- 要解决这个问题，对采样、聚类、流量分割等要求非常的高，这也是为什么A/B测试工具不能像很多统计工具一样，埋个点看数据，再根据数据反推业务逻辑，而是要充分与业务结合，从一开始就应该考虑业务策略，让用户去选择适合其口味的产品。


## 灰度发布

A/B测试就是上两个方案，部署后看效果。根据效果和一些结果参数决定采用哪个方案。
- 灰度发布是切一部分业务使用新方案，看效果如何，是否有bug，会遇到什么问题。如果一切OK，就把全部业务切到新的方案上执行。发布后让部分用户使用新版本，其它用户使用旧版本，逐步扩大影响范围，最终达到全部更新的发布方式 。
- 灰度发布，又称金丝雀发布。
  - **金丝雀发布**这一术语源于煤矿工人把笼养的金丝雀带入矿井的传统。矿工通过金丝雀来了解矿井中一氧化碳的浓度，如果一氧化碳的浓度过高，金丝雀就会中毒，从而使矿工知道应该立刻撤离。 ——《DevOps实践指南》
- A/B测试系统的一个常用场景是App/小程序/后端服务精细化运营过程中的上线迭代管理，通常被称为灰度测试或者灰度上线。

![](https://pic1.zhimg.com/80/v2-a5bfd4a6e475603afe930b26f7b2eff4_720w.jpg?source=1940ef5c)

## 正向代理

正向代理类似一个跳板机，代理访问外部资源。从网站的角度，只在代理服务器来取内容的时候有一次记录，有时候并不知道是用户的请求，也隐藏了用户的资料，这取决于代理告不告诉网站。具体操作上，客户端必须设置正向代理服务器，当然前提是要知道正向代理服务器的IP地址，还有代理程序的端口。
![](https://images2015.cnblogs.com/blog/305504/201611/305504-20161112124853014-1532060796.png)

总结：正向代理是一个位于**客户端**和**原始服务器**(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。

正向代理的用途：
- （1）访问原来无法访问的资源，如google
- （2）可以做**缓存**，加速访问资源
- （3）对客户端访问**授权**，上网进行认证
- （4）代理可以记录用户访问记录（上网行为管理），对外**隐藏**用户信息

参考：[正向代理与反向代理总结](https://www.cnblogs.com/Anker/p/6056540.html)

## 反向代理

**反向代理**（Reverse Proxy）是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。

反向代理的作用：
- （1）保证内网的安全，可以使用反向代理提供WAF功能，阻止web攻击；大型网站，通常将反向代理作为公网访问地址，Web服务器是内网。
  - ![](https://images2015.cnblogs.com/blog/305504/201611/305504-20161112124341280-1435223816.png)
- （2）负载均衡，通过反向代理服务器来优化网站的负载
  - ![](https://images2015.cnblogs.com/blog/305504/201611/305504-20161112124423530-566240666.png)


正向代理与反向代理的区别：
1. 服务对象不同
  - 正向代理，代理的是客户端，也就是例子中的A，服务端不知道实际发起请求的客户端；
    - <img src="https://pic1.zhimg.com/50/v2-77571820cf18c25031ffcea52a9250db_hd.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="1101" data-rawheight="456" class="origin_image zh-lightbox-thumb" width="1101" data-original="https://pic1.zhimg.com/v2-77571820cf18c25031ffcea52a9250db_r.jpg?source=1940ef5c"/>
  - 反向代理，代理的是服务端，也就是例子中的C，客户端不知道实际提供服务的服务端
    - <img src="https://pic2.zhimg.com/50/v2-47a87c2f02f8451c44f1b2f2ce6dea86_hd.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="1122" data-rawheight="547" class="origin_image zh-lightbox-thumb" width="1122" data-original="https://pic1.zhimg.com/v2-47a87c2f02f8451c44f1b2f2ce6dea86_r.jpg?source=1940ef5c"/>
2. 安全模型不同
  - 正向代理允许客户端通过它访问任意网站并且隐藏客户端自身，因此必须采取安全措施以确保仅为授权的客户端提供服务
  - 反向代理都对外都是透明的，访问者并不知道自己访问的是代理，访问者不知道服务节点的存在，认为处理请求的就是代理节点

总而言之，正向代理是从客户端的角度出发，服务于局域网用户，以访问非特定的服务，其中最典型的例子就是翻墙；反向代理正好与此相反，从服务端的角度出发，服务于所有用户，隐藏实际的服务节点，服务节点的架构对用户透明，以代理节点统一对外服务。

![](https://images2015.cnblogs.com/blog/305504/201611/305504-20161112130135639-1005446770.png)

[反向代理为何叫反向代理？](https://www.zhihu.com/question/24723688/answer/583903276)

## 平滑发布

### 介绍

**平滑发布**就是发布的过程中不影响用户的使用，系统不会因发布而暂停对外服务，不会造成用户短暂性无法访问。

`灰度发布`与`平滑发布`其实是关联的。`
- 当服务器的数量只有一台的时候，不存在灰度发布，一旦发布了就是所有用户都更新了，所以这个时候只有平滑发布。
- 当服务器数量大于一台的时候，只要每台服务器都能达到平滑发布的方式，然后设定好需要发布的服务器占比数量，就可以实现灰度发布了。

### 实现方式

平滑分布一般通过Nginx负载均衡实现，示例见：[平滑发布与灰度发布](https://blog.csdn.net/IT_ZRS/article/details/110676908)

```shell
vim /etc/nginx/nginx.conf # 编辑nginx配置文件
nginx -t 
nginx -s reload # 重新加载
```

![](https://img-blog.csdnimg.cn/20201205092008239.png)

- [系统架构设计：平滑发布和ABTesting](https://www.cnblogs.com/wzh2010/p/13458723.html)

实施方案
- 1、跟nginx代理服务器约定了一个健康检查的接口
- 2、通过接口返回的http状态码来让ngx是否分流用户请求
- 3、根据提供的这个服务健康检查的接口：nginx判断只要某个实例的接口返回5xx的状态码，即把该实例下线（nginx不会把流量转发到该实例）

### 优化方案

平滑发布做完之后，确实给我带来很大的便利，不用每次发布都发公告，不重要的或者非功能性的内容发布了就是了。

但是用久了，客户量上去之后，又遇到一个问题，那就是每一次业务大变更，大型发布都是直接发布到生产，这样可能存在风险。设计师设计的功能，用户不一定完全接受，一旦上线新版本，收到一大堆的吐槽，都是用户呀，如果能在小范围人群内进行灰度试用，完成平稳的过度和使用反馈之后，优化后再上到生产会更好一点。

所以这边需要思考和设计一套统一的技术方案，未来无论云办公还是其他的业务系统，都能通过灰度发布在可指定的小范围内先进行体验和功能验证。基于上面的平滑，我们在Nginx反向代理服务器上动心思，让nginx来帮我们做ABTesting的方案。以下是我们尝试的几种方案：

**Nginx反向代理：来路IP策略**

步骤
- 1、进入云办公系统，进入Nginx反代服务器
- 2、Nginx读取来路IP的AB名单
- 3、根据IP AB名单进行流量转发(名单A走特定实例，名单B走云办公原有集群实例)

![](https://img2020.cnblogs.com/blog/167509/202008/167509-20200823171859322-737387173.png)

优缺点
- 1、配置简单，原资源平台的灰度升级就是根据IP名单来划分设计升级的
- 2、外部计算机很多都是非固定IP，这个适合在公司内网实现，比如只是配置公司内网的IP。

**2、Nginx反向代理：$.Cookies策略**

步骤
- 1、进入云办公系统，进入Nginx反代服务器
- 2、Nginx读取Http请求的Cokie的version信息（也可以是别的key）
- 3、根据Key的版本来进行流量转发(比如Version1.1走特定集群，Version1.0走通用集群实例) 

![](https://img2020.cnblogs.com/blog/167509/202008/167509-20200823172806522-513799881.png)

优缺点
- 1、配置简单，根据Nginx的 $COOKIE_version 属性来判断
- 2、相对稳定，对需要开放名单的用户，在Cookie头部加入特定的版本即可，应用只要少许的开发量
- 3、首次访问静态页面可能不会产生cookie

备注：这是团队内认为最好的Nginx代理方案，同理，User-Agent和Header都可以做此种类型的判断，但是Header需要侵入底层HttpRequest去业务添加，不建议。

**3、AB集群+业务代理方式**

![](https://img2020.cnblogs.com/blog/167509/202008/167509-20200823173724467-1987394586.png)

步骤
- 1、进入云办公系统，两种方式进入系统，一种是登录页登录：~/login ，一种是default页面带uckey登录：~/default?usertoken=#usertoken#
- 2、登录的时候和usertoken传入的时候进去 路由代理模块,进行用户信息校验，根据不同的人员和部门(人员和部门配置归属AB名单)分流到两个不同的AB集群
- 3、根据转发跳到具体的实例集群域名下（可以配置AB集群拥有不同域名,更容易区分）

优缺点 
- 1、与Nginx剥离，不用依赖公司的通用平台和技术部的实现
- 2、需要申请AB集群，AB集群拥有不同的域名。
- 3、如果是前后端分离情况下，需要保证静态站点和服务站点均申请AB集群
- 4、所有入口需要统一做代理，有一定的开发量

## 抽样策略

- 在灰度测试的技术实现里，一个关键的部分是试用用户样本的选择策略。也就是说，新版本上线测试的首批（以及后续批次）灰度用户是怎么筛选出来，决定了灰度测试的技术选型和具体实现。每一个新功能分别由哪些测试用户来试用，谁扮演“小白鼠”的角色
- 广泛使用的样本选择策略
    - 白名单
    - 随机抽样
    - 按照某种规则抽样
    - A/B测试科学采样

### 实验组划分

- 实验分组的成功与否直接影响实验的数据，从而影响到实验的结果和结论。根据前文所述，随机化分组是控制实验无关变量(各组样本的条件尽量一致)的有效手段

#### 2.1 完全随机化分组
 
- 随机抽样一般借助Hash函数依据实验对象ID(Hash因子)将实验对象映射到实验分桶。
 
```
BucketID=Hash(实验对象ID，策略ID，流量层ID)%100+1
```
 
- 这样每个实验对象会得到唯一的BucketID，同时会随机均匀散落在\[1，100\]范围内。在配置实验时，根据实际需求，为各个版本均匀切分流量。譬如A版本划分10%的流量，则BucketID从0~10的用户被划分到 A 版本，以此类推。
- 在实际应用中，假如实验对象为用户，实验对象ID可以取用户ID、用户手机号等。在大流量业务中(推荐、搜索等)，完全随机化实验基本可以达到控制无关变量(消除无关变量影响)的目的。
 
#### 2.2 分层随机抽样(Stratified sampling)
 
![](https://pic1.zhimg.com/80/v2-57c71702ac1027c780913b5f397a1a10_720w.jpg)
 
- 在试验对象数量较小的情况下，比如2000量级左右，完全随机抽样可能无法保证试验分组的无偏性。比如，在网约车业务中，司机的做单能力存在天然差异且方差较大，此时采用随机抽样存在试验各分组司机做单能力存在较大差异的风险，进而影响策略效果评估。此时，可以考虑分层随机抽样，即先根据司机的历史做单能力将司机分为不同的分组，然后在各分组内再随机抽样。
 
#### 2.3 时间片分组
 
![](https://pic2.zhimg.com/80/v2-89410b08c8d1c49072701ad7328bce25_720w.jpg)
 
- 传统业务中，比如推荐、搜索等，流量因子是相互独立的、随机的，服从独立同分布。但是在O2O业务中，比如外卖、网约车等，实验对象(骑手、商家、司机等)面临着复杂的线下环境，由于存在一定程度的竞争关系，使得实验对象不再独立，此时传统的实验方式可能会存在问题。一种解决方法是采用时间片轮转分组方法。示意图如下:
 
![](https://pic3.zhimg.com/80/v2-5e9404dba0344599baf1c7c970fde296_720w.jpg)
 
#### 2.4 分组合理性评估(A/A Test)
 
- 实验分组方案确定后，正式实验开始前，在有条件的情况下可以通过A/A Test确认分组间的无偏性，即是否控制住了无关变量。
 
![](https://pic4.zhimg.com/80/v2-06087dbfacb7a47fcee10d838137cc8f_720w.jpg)
 
- 所谓的A/A Test是指实验组与对照组采用相同的策略，用来验证试验分组是否存在天然的差异(比如点击率、平均阅读时长、留存、人均GMV、司机做单能力等)。
 
####  2.5 实验分组比例设计
 
- 根据不同 目的和实验风险，选择不同的实验划分方案，如下图:
 
![](https://pic1.zhimg.com/80/v2-effa555cdc601a3734e803af4d94dbd8_720w.jpg)

- 参考：[策略算法工程师之路-因果分析.科学实验评估](https://zhuanlan.zhihu.com/p/161387546)


## A/B实验三大特性

- A/B测试具有三大特性：先验性、并行性和科学性。
    - 先验性：互联网以往的方式是先发布版本，再通过数据验证效果，分析版本的好坏。而A/B 测试是通过采用代表性样本、用户流量划分以及小流量测试等方式，来获得具有代表性的试验结论。简单来说，就是先通过低代价，小流量的试验，再推广到全流量的用户。
    - 并行性：将两个或两个以上的版本同时试验，确保每个版本所处环境的一致性，即其他条件都相同，同时发布同时生效，这样便于更加科学客观地进行对比。同时，可以节省验证的时间，无需在验证完一个版本之后再验证另一个。
    - 科学性：即用户流量分配的科学性。将相似特征的用户均匀的分配到试验组中，确保每个组别的用户特征的相似性，从而避免出现数据偏差，使得试验的结果更有代表性。

## A/B 测试的使用误区

- 误区一：轮流展现不同版本
    - 先发布A版本一段时间后，再发布B版本，通过对比两个版本的数据情况来评定版本的好坏。这种做法并不能保证每个版本所处的环境相同，受众群体可能会有明显区别。以至于难以判断最终效果是否有差异，或导致效果不同的原因。
    - 正确做法：不同版本并行（同时）上线试验，尽可能降低所有版本的测试环境差别。
- 误区二：选择不同应用市场投放/随机选取用户测试
    - 将不同版本打包，分别投放到不同的应用市场，最终根据数据反馈最优的版本，将该版本全量上线。或随机选取一部分用户（甚至是公司内部人员）进行前期试用，根据数据反馈决定迭代版本。这种做法违背A/B测试的科学流量分配的原则。
    - 正确做法：科学的进行流量分配，保证每个试验版本的用户特征类似。
- 误区三：让用户自主选择版本
    - 同时发布多个版本，在产品界面提供版本入口，由用户自主选择使用哪一版本，再根据数据进行分析，从而评估出最好版本。这种做法无法预估每个版本的用户数、用户使用时长以及用户特征，最终导致了试验结果的不准确。正确做法：让用户展现对不同版本的真实使用体验，应实时关注各版本的数据表现，并根据数据反馈及时调整试验流量。
- 误区四：对试验结果的认知和分析过浅
    - 这一误区又包括了两个不同的内容：
        - 认为只有当试验版本结果优于原始版本时，试验才算成功。事实上，A/B 测试是用于选择最佳版本的工具。试验可能出现的结果分为三种：试验版本有提升（试验版本最佳）、无明显差异（试验版本和原始版本均可）、试验版本的表现比原始版本糟糕（原始版本最佳），但这三种结果均可说明试验的成功。
        - 单从试验的整体数据结果，就推论所有场景的表现效果。例如：当A/B测试的数据表明试验版本差于原始版本时，就认定所有的地区或渠道的效果都是负面的。但如果细分每个版本中不同浏览器的数据，可能会发现：由于某一浏览器的明显劣势，导致整体试验数据不佳。
    - 因此，不要只专注于试验数据的整体表现，而忽略了细分场景下可能导致的结果偏差。
    - 正确做法：在分析试验整体数据的同时，需要从多个维度细分考量试验数据结果

## A/B方案

- AB实验的基本原理是“控制变量法”。
- 设指标数值=F（{隐变量列}、{显变量列（含方案变量）}）

## A/B实现平台

业界的AB平台的设计都参考了谷歌重叠实验框架的论文：《[Overlapping Experiment Infrastructure: More, Better, Faster Experimentation](http://research.google.com/pubs/pub36500.html)》，[译文](http://www.flickering.cn/uncategorized/2015/01/)。

[原文链接](https://blog.csdn.net/GFJ0814/article/details/92422510)

[AB实验平台在贝壳找房的设计与实践](https://blog.csdn.net/GFJ0814/article/details/92422510)

通常网站会利用分域、分层、分桶的机制保证流量高可用以及分流的灵活性和科学性。

### 实验分类

根据**实验种类**分类
- **水平**实验：类似于Overlapping Layer中的实验，是属于同个“层”的实验，实验是互斥的，在同一“层”上实验可以理解为是同一种实验，例如：关键词“层”表示这一层的实验都是关键词相关的，该层上存在实验H1和H2，那么流量绝对不会同时命中H1和H2。
- **垂直**实验：类似于Non-overlapping Layer中的实验，分布于不同“层”之间，实验是不互斥的，例如在关键词“层”和CTR“层”上在相同的分桶上配置了实验V1和V2，那么流量可以同时命中V1和V2。
- **条件**实验：表示进入某“层”的实验需要满足某些条件，水平实验和垂直实验都可以是条件实验。

水平、垂直分流模型分为以下两个部分：
- 仅包含水平实验 ： 最基础的实验需求，全部实验独占一个Layer，每个实验覆盖若干个桶，例如图4中的Layer_1，将流量分为10份，包含三个实验，这三个实验分别占用3、3、4份流量。
- 同时包含水平、垂直实验：一个Layer中同时包含垂直、水平两种类型的实验。例如图4中的Layer_2和Layer_3，将最后的4份流量用来做垂直实验，包含两个垂直实验，分别是Exp_6和Exp_7。

![](https://p0.meituan.net/travelcube/70a59544188c9168258e0953efaa04c237627.jpg)


根据**流量类别**分类，主要了为了用户体验，使平台在操作上更加的简单、易用：
- **普通**实验：最基本的实验，根据流量类别进行配置。
- **引用**实验：流量分类是整个配置中心基础，但实际上存在一些实验是跨流量了，而引用实验则可以配置在不同的流量种类中。
- **全局**实验：可以理解为特殊的引用实验，全局实验在所有流量上都生效。


### 分层实验模型

​作为实验平台，支持同时运行大量AB实验是其基本要求。多实验并行的情况下，我们根据共享同一份流量情况下，两个实验效果是否会产生干扰，将实验之间的关系分为正交实验和互斥实验。
- **互斥实验**：如果分层共享同一份流量就有可能出现实验效果之间相互干扰的问题，这样的实验叫互斥实验，也就是如果实验一和实验二是互斥关系，那么经过实验一的流量就不能进入到实验二。
- **正交实验**：如果实验之间共享同一份流量实验效果之间不干扰，这样的实验我们叫正交实验，这种情况下，流经两个实验的流量是可以共享的，流经实验一的流量也可以流经实验二。

多实验并行过程中，既有正交实验，也有互斥实验并且要保证流量在实验过程中科学合理的分配。分层实验模型就提出了“层”的概念。层的原则是：同一层存在多个互斥实验，流量流经该层最多可以参与一个实验。层与层之间，流量是正交的，也就是说流量在穿越每一层实验时候，都会被再次随机打散，经过上层实验一的流量可能会经过下层的任何一个实 验，可能是实验一，也可能是实验二。

![](https://img-blog.csdnimg.cn/img_convert/666df0662788600c46a914b60a0e102e.png)

实验过程中，一般会从总体流量中按照一定维度划分流量区域来做实验，比如一部分实验做在PC端，一部分做在M端。如此，就引出了另外一个概念，“**域**”。这里划分出的流量池就是一个域，在这个域里还可以进行分层实验，不同域之间流量隔离，所有的流量域加起来共享100%流量。

![](https://img-blog.csdnimg.cn/img_convert/2d41aa74cedbdcd5e25d3602df482f80.png)

通过域、层、实验之间的嵌套关系组合，就可以满足我们很多场景的实验，划分想要的流量域，运行想要的各种不同的实验类型。

### 流量分桶

模型有了，怎么分流也很重要，那什么是分流呢？**分流**指根据分流算法策略为每层的每个实验分配相应的流量，从请求角度来说，是让每个请求都能在各层都能准确稳定的命中到相应实验。分流也叫**流量分桶**，为什么叫流量分桶呢？

每层的每个实验的实验组和对照组就是一个**桶**，每层的流量一共是100，假设这层有两个实验（实验一和实验二），流量配比各为50%，每个实验各有一实验组和对照组，实验组和对照组平分流量各得25%，那么每层实验就有4个桶。整体流量按桶划分，从0开始编号的话，可以认为，实验组一的桶装的是0-24的编号，实验组二的桶装的是25-49编号，类推，实验组二的桶装的是75~99的编号。一个流量请求在每一层中只能命中到一个实验组，也就是说只能被分到一个桶内。一般我们会选择用户id和实验层id哈希取模（mod=f(uid, layer)%100），得到的值在哪个桶内，该请求就命中哪个实验的那个组,这样 保证了用户在每层命中的实验是随机且是稳定的。

### 架构与实验

### 滴滴

【2021-5-11】滴滴：dtp服务请求apollo的时候会带一个唯一的id（如uid），apollo会根据这个uid来进行分组，一个uid会固定分到某个组，服务代码里植入Apollo的sdk，只区分控制组（对照组 group_id=0），另外开启一个监听接口，每隔几秒刷新Apollo上的配置文件，便于快速生成；实验开启后，Apollo平台上配置的关键指标及计算方法（SQL）开始展示，平台自动评估显著性，判定此次实验是否有效

![](https://oscimg.oschina.net/oscnet/d3ccd445-1b12-4a8b-8247-dbb85ae5dc33.png)
- Apollo是适用于多种场景的线上A/B 实验与灰度发布平台，无论是想优化APP产品、后端算法还是运营策略，都可以通过实验来验证优化效果。与此同时，它支持复杂规则的定向投放、服务降级、配置同步、模型动态升级等应用场景。Apollo通过可视化的操作平台、科学的流量划分和一对一的实验设计，为产品经理、运营推广人员、数据分析师提供A/B 实验的指标计算及多维度的数据分析，为各种应用场景量身打造最优质的解决方案。
- A/B实验过程
  - ![](https://img-blog.csdnimg.cn/20200529135245988.png)
  - 第一步： 设计实验方案，包括确定实验对象，划分实验组，确定实验提升目标等。
  - 第二步： 进行人群分组，一般是一个空白组加一个或多个实验组
    - ① CR（Complete Randomization）完全随机分组 —— 由于完全随机的不确定性，分完组后，各个组的实验对象在某些指标特性上可能天然就分布不均。均值，标准差等差异较大。如果分组不均，则将会影响到第四步的实验效果分析的进行，可能遮盖或者夸大实验的效果。[图](https://img-blog.csdnimg.cn/20200529135246222.png)
      - ![](https://img-blog.csdnimg.cn/20200529135246222.png)
    - ② 改进版：对CR进行简单的一步优化，即进行RR（Rerandomization），RR是在每次跑CR之后，验证CR的分组结果组间的差异是否小于实验设定的阈值。当各组的观察指标小于阈值或者重新分组次数大于最大允许分组次数后，停止分组。[图](https://img-blog.csdnimg.cn/20200529135246397.png)
      - ![](https://img-blog.csdnimg.cn/20200529135246397.png)
    - RR通过牺牲计算时间，能在一定概率上得到符合要求的分组。重分组次数与输入的实验对象样本大小相关。样本量越大，需要进行重分的次数一般较少。但是RR分组能得到符合要求的分组有一定的概率，且需要花更多的时间。
    - ③ 改进版：自适应分组，在一次分组过程中分出观察指标均匀的分组结果。
      - Apollo实验平台实现了滴滴AI LAB团队设计的Adaptive（自适应）分组算法。Adaptive分组方法可以在只分组一次的情况下，让选定的观测指标在分组后每组分布基本一致，可以极大的缩小相对误差。相比于传统的CR分组，Adaptive分组的算法更加复杂，在遍历人群进行分组的同时，每个组都需要记录目前为止已经分配的样本数，以及已经分配的样本在选定的观测指标上的分布情况。从分流人群中拿到下一个要分的对象后。会对实验的各个组进行计算，计算该对象如果分配到本组。本组的观测指标分布得分情况。然后综合各个组的预分配得分情况，得到最终各个组对于该实验对象的分配概率。
      - ![](https://img-blog.csdnimg.cn/20200529135246932.png)
  - 第三步： 将需要实验的策略，方案或者功能施加到各个组，收集数据
  - 第四步： 对实验关心的指标进行分析观察
- 心得
  1. 确认要实验的变量: 尽量保证每次实验只针对一个变量进行测试。
  1. 实验前明确关键指标: 基于假设，定义关键指标进行观测。不要订阅大量指标，或者，实验中后期再进行选择。
  1. 控制实验运行时间: 运行实验时不注意时间控制，随意结束实验的做法并不可取。
  1. 实验分组要保证受控: A/B 实验分组一定要保证在受控的情况下进行对比测试。受控是指除了要测试的变量外，所分组的组间差别尽量小，这样才能保证组间的差异对实验的影响是在可控范围内的。
  1. 实验结果分析要关注置信度: 不光要看指标本身的变化，还要看它的置信度。置信度是个统计学上的概念。我们抽取了一部分用户做实验，那么在这部分人身上

观察到的指标提升，是否在功能全量之后也能在全部用户中带来相同的指标提升呢？这就是置信度能告诉我们的。版本 B 带来了75%的转化率提升。于是，得出结论：版本 B 胜出。但这究竟对不对呢？结果并不一定，我们还要考虑以下两个情况：
- **样本特性**：上面案例里，如果样本大小只有4个人，恰好其中3个喜欢按钮效果。那么这75%的提升置信度是极低的，因为真的放大到所有用户，喜欢按钮效果的人比例可能根本没有75%那么高。
- **提升幅度**：如果样本量合理的情况下，例如在500人左右，转化率提升达到99%，那么这个结论的置信度是比较高的，很有可能放到全量之后，转化率也会提升到近似99%。但是如果观察到的提升率只有1%左右，那此时置信度就会比较低，很难说全量之后转化率就会提升1%。这1%的提升可能是抽样误差导致的，还需要更大的样本量来提高置信度。

参考：
- 【2017-5-22】[是TA，让我们更懂用户！滴滴的神秘工具，Apollo！](http://cache.baiducontent.com/c?m=zp8EMft6kSasi8kbAIkwDtY29ObanSZGJ21X_EwSCSRc-8nN4fXovWZgORRA_iD2v1364q3jgKI_pduKsuKBXYSC2VC2UvVIuP4yHjsHposWdfjuO3G5HKCymG-Qd1dAUuuZcsja-WhNZdSQ9fiSeK&p=8e6ddd15d9c041a41dbe9b7c544ccd&newp=8b2a971386cc42af53b2c222555f82231610db2151d6db01298ffe0cc4241a1a1a3aecbf2c251b02d9c277620aad4e5ceff132743d0034f1f689df08d2ecce7e79&s=3dfa05a594c0e171&user=baidu&fm=sc&query=%B5%CE%B5%CE+Apollo&qid=d20808140001fd82&p1=1)
- 【2020-5-29】[滴滴数据驱动利器：AB实验之分组提效](https://blog.csdn.net/DiDi_Tech/article/details/106424045)


#### 美团

美团整体架构分为四层：
- Web层：提供平台UI，负责应用参数配置、实验配置、实验效果查看以及其他。
- 服务层：提供权限控制、实验管理、拉取实验效果等功能。
- 存储层：主要是数据存储功能。
- 业务层：业务层结合SDK完成获取实验参数和获取应用参数的功能。

![](https://p0.meituan.net/travelcube/4c3f775d572de5f3b1371644916e644260396.jpg)

[美团点评效果广告实验配置平台的设计与实现](https://tech.meituan.com/2019/11/28/advertising-performance-experiment-configuration-platform.html)


#### 贝壳

![](https://img-blog.csdnimg.cn/img_convert/1629d86e3434d5ddae5f05c854af2d73.png)

ab平台架构主要包括web层、api层、数据层、存储层，核心分流服务构成：
- **web层**：主要提供用户界面化的操作来配置实验，创建实验受众，创建白名单，查看实验实验效果等功能，其中用户配置实验过程中最重要的一部分就是实验受众。
- **实验受众**：指的是用于实验的流量人群。目前受众分为两种，分别是基于维度标签组合形成的AB受众和基于用户画像标签圈定的人群包受众：
- **AB受众**：支持按照设备（ios、android）、城市、URL（比如区分贝壳pc和m站）等维度生成标签，再由标签之间组合形成各个维度的受众，比如北京安卓用户。这种受众通过解析请求的cookie信息，正则匹配标签内容判断是否应该进入对应受众。
- **人群包受众**：因为人群包受众是通过DMP平台提供的用户画像标签（比如城市、最近的活跃度等）圈出来的人群id集合，所以也叫DMP受众，目前这部分受众的用户的id取值逻辑主要取自于设备id。通过判断用户请求信息的设备id是否包含在人群id集合中，来判断是否应该进入到该受众。

​上面提到了白名单，那么白名单是什么呢？我们可以把白名单理解为一种特殊的受众，白名单中包含了人为添加的用户id。它一般应用于一个实验的某个实验组上，为这个实验组指定白名单，那么在对这个实验分流的时候，白名单的用户就忽略分流策略，直接命中配置了该白名单的实验组。白名单常用于测试情况下，指定测试人员命中实验组，方便测试。

​配置实验受众、指定了实验起始和过期时间、配置实验组和对照组的流量之后，就可以开始实验了。
![](https://img-blog.csdnimg.cn/img_convert/884e9cef3d096281b616767770ea134f.png)

**api层**：提供业务方调用ab平台接口，用户请求ab平台的api时，解析请求header中的cookie信息判别受众以及获取用户id用于实验分流。根据实验场景不同，api分为客户端API和服务端API。

​客户端api主要用于客户端实验比如UI等实验，API请求逻辑处理如图
![](https://img-blog.csdnimg.cn/img_convert/0997b137443baf6087eb9e9a86d16348.png)

服务端API主要用于后端逻辑优化、算法策略实验对比等，由于从前端到后端实验调用处，链路可能很长，对于请求信息的传递的保存和传递显得困难。因此，我们设计了uniqId，当用户请求线上域名的时候，负载均衡层会生成一个唯一的uniqId,将用户的请求信息保存到redis，之后的请求链路中，会将uniqid传递给后端，该参数也是请求ab服务时必不可少的参数。API逻辑如图所示

![](https://img-blog.csdnimg.cn/img_convert/ec336dea3128fd6c3dc5c5fc0c4694b0.png)

**分流服务**：主要提供流量划分的功能。
- 分流依据：ab平台利用用户id进行分流，这其中包括标记新用户或访客的lianjia_uuid、注册用户的lianjia_ucid、针对移动设备的lianjia_device_id。
- 分流实现：基于多层实验模型的流量分桶原理，ab平台对其做了适当的简化，以更加适合目前我们的业务需求。我们定义每层一个实验，各层之间流量正交。每个实验受众，可以理解为一个域。一个受众可以用于多个实验。

​在程序设计中，我们取map集合，命名traffics，将运行中的实验加载到traffics中，traffics的key是每个实验的名字，比如exp1，traffics的值是traffic，每个traffic也是一个map结构，traffic的key是每个实验分组的名字，比如这里是group1,group2。traffic的值是每个实验组的桶内编号的集合，这里是一个set结构来存储。如图所示
![](https://img-blog.csdnimg.cn/img_convert/6e1d234993ae47cfd3f19b55c44188dc.png)

分流过程
![](https://img-blog.csdnimg.cn/img_convert/b890373101df08ea8231798fc604f43e.png)

业务方通过解析得到的实验配置，控制该用户命中不同的逻辑。

​ 数据层：将流量的实验分组信息与用户行为日志做关联，分析实验的指标数据。实验效果分析包括实时数据分析和离线数据分析，过程分别如下：

​ 离线数据分析：流量分组日志实时写入到kafka，这部分分组数据作为离线数据一部分写入到hive表中，与存储在hive表中的用户行为数据，按照用户id做关联，关联得到的用户在各个实验方案下的行为数据写入到clickhouse中。

​ 实时数据分析：流量分组日志实时写入到kafka，这部分分组数据作为实时数据写入到hbase中。同时，用户行为日志数据由dig埋点服务实时写入到行为日志的kafka中，spark-streaming实时任务仍然按照用户id整合kafka中的行为日志数据和存储在hbase中的流量分组数据。整合之后的数据实时写入到kafka，再由实时任务消费写入到clickhouse。

![](https://img-blog.csdnimg.cn/img_convert/55447a6b7afb5cafd2eebf246ab46d10.png)

​ 经过对存储在clickhouse中的数据通过复杂的SQL进行聚合分析，得到用户在相应实验方案下的pv、uv、转化等数据

![](https://img-blog.csdnimg.cn/img_convert/220bf6c27330a2f153a5d3ed767f5ac2.png)
![](https://img-blog.csdnimg.cn/img_convert/12f218489f4092f9fad85457be8996e0.png)

存储层：ab平台的存储层主要包括：
- mysql：用于保存实验配置、白名单配置、实验受众信息。
- Hbase：存储用户命中AB实验分组信息，用于实时处理的分组日志数据整合。
- redis：借助其高性能的数据写入和读取特性，用于存储和用户请求分流直接相关的uniqId对应的cookie信息、白名单包含的用户id、人群包包含的用户id集合，保证请求分流能够1-2毫秒内快速高效完成。
- clickHouse：这是一款能够支持十亿级日志数据秒级自定义分析的查询引擎，其高效的存储性能以及丰富的数据聚合函数成为实验效果分析的不二选择。离线和实时整合后的用户命中的实验分组对应的行为日志数据最终都导入了[clickhouse](ClickHouse Practice)，用于计算用户对应实验的一些埋点指标数据（主要包括pv、uv）。


[a/b实验平台](https://blog.csdn.net/lsgqjh/article/details/97066691)

![](https://img-blog.csdnimg.cn/20190724020924493.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xzZ3FqaA==,size_16,color_FFFFFF,t_70)



# interleaving

## 问题

- 算法工程师们日益增长的AB Test需求和线上AB Test资源严重不足之间的矛盾 —— 需要一个快速的线上评估方法
- abtest的好处是能够对多个策略的效果差异给出定量的评估，但是也存在一些问题
  - ① 如果两个策略的效果差异较小，abtest容易给出波动较大的结果; 
    - 即使AB两组之间重度可乐消费者的微小不平衡也可能对结论产生不成比例的影响
        - 总的测试人群中，对于可乐的消费习惯肯定各不相同，从几乎不喝可乐到每天喝大量可乐的人都有。
        - 可乐的重消费人群肯定只占总测试人群的一小部分，但他们可能占整体汽水消费的较大比例。
    - Netflix场景下，非常活跃用户的数量是少数，但其贡献的观看时长却占较大的比例，因此，Netflix AB Test中活跃用户被分在A组的多还是被分在B组的多，将对结果产生较大影响，从而掩盖模型的真实效果。
    - 如何解决这个问题呢？一个方法是不对测试人群进行分组，而是让所有测试者都可以自由选择，按比例平均，这个方案（interleaving）的优点
      - 消除了AB组测试者自身属性分布不均的问题；
      - 通过给予每个人相同的权重，降低了重度消费者对结果的过多影响。
  - ② 需要较长时间（一般是一周）才能判断结果，会导致效果迭代速度较慢。

## interleaving

为了解决这个问题，采用interleaving效果评估方式作为补充。
- Interleaving方式的好处是所需流量较小，灵敏度较高，一般24小时之内可以给出结论，但是它**只能给定性结论而不能给定量结论**。
- Interleaving的基本思想是把两个策略的结果混合在一起，通过统计分析用户选择哪个策略的概率更大。具体列表混合的实现方式有多种。下面介绍比较简单使用的一种，叫Balanced方式。

Netflix设计了一个两阶段的线上测试过程（如图2）。参考：[Netflix推荐系统模型的快速线上评估方法——Interleaving](https://zhuanlan.zhihu.com/p/68509372)
- 第一阶段利用被称为Interleaving的测试方法进行候选算法的快速筛选，从大量初始想法中筛选出少量“优秀的”Ranking算法。
- 第二阶段是对缩小的算法集合进行传统的AB Test，以测量它们对用户行为的长期影响。

![](https://pic2.zhimg.com/80/v2-366525b613a259d50a3c5e1abfd57d6d_720w.jpg)
使用Inter leaving进行快速线上测试。 用灯泡代表候选算法。 其中，最优的获胜算法用红色表示。Interleaving能够快速地将最初的候选算法集合进行缩减，相比传统的AB Test更快地确定最优算法。

AB Test和Interleaving之间的差异。
- 在传统的AB Test中，Netflix会选择两组订阅用户：一组接受Ranking算法A的推荐结果 ，另一组接受Ranking算法B的推荐结果。
- 在Interleaving测试中，只有一组订阅用户，这些订阅用户会接受到通过混合算法A和B的排名生成的交替排名。

- ![](https://pic4.zhimg.com/80/v2-55f1e4abf7ee76ba70797be3c7a67487_720w.jpg)
- 传统AB Test和Interleaving 在传统AB Test中，测试用户分为两组，一组暴露于排名算法A ，另一组暴露于算法B，在两组之间进行比较观看时长等核心评估指标。另一方面，Interleaving将所有测试用户暴露于算法A和B的混合排名，再比较算法相对应的item的指标

这就使得用户同时可以在一行里同时看到算法A和B的推荐结果（用户无法区分一个item是由算法A推荐的还是算法B推荐的）。进而可以通过计算观看时长等指标来衡量到底是算法A好还是算法B好。

## 局限性

Interleaving方法也存在一定的局限性，主要是下面两点：
- 工程实现的框架较传统AB Test复杂。由于Interleaving实验的逻辑和业务逻辑纠缠在一起，因此业务逻辑可能会被干扰。而且为了实现Interleaving，需要将大量辅助性的数据标示添加到整个数据pipeline中，这都是工程实现的难点；
- Interleaving毕竟只是对用户对算法推荐结果偏好程度的相对测量，不能得出一个算法完整的表现。比如我们想知道算法A能够将用户整体的观看时长提高多少，使用Interleaving是无法得出这样的结论的。为此Netflix才设计了Interleaving+AB Test两级实验结构，完善整个线上测试的框架。


# 服务部署

- [蓝绿部署、A/B 测试以及灰度发布](https://zhuanlan.zhihu.com/p/43047172)
- 蓝绿部署、 A/B 测试、灰度发布，这三者之间究竟有何不同？

## 蓝绿部署
 
- Martin Flower曾在[文章](https://martinfowler.com/bliki/BlueGreenDeployment.html)中阐述了蓝绿部署的整体要点。
- 基本上，蓝绿部署是一种以可预测的方式发布应用的技术，目的是减少发布过程中服务停止的时间。简单来说，你需要准备两个相同的环境（基础架构），在蓝色环境运行当前生产环境中的应用，也就是旧版本应用，如图中App1 version1、App2 version1、App3 version3。

![](https://pic1.zhimg.com/80/v2-75a5ab6fb7ab5d189cd4b81cb34d72b0_1440w.jpg)
 
- 当你想要升级App2到version2，在蓝色环境中进行操作，即部署新版本应用，并进行测试。如果测试没问题，就可以把负载均衡器／反向代理／路由指向蓝色环境了。
![](https://pic4.zhimg.com/80/v2-0607536cf7ea98616ea282f2d2cce837_1440w.jpg)

- 随后你需要监测新版本应用，也就是App2 version2是否有故障和异常。如果运行良好，就可以删除App2 version1使用的资源。如果运行出现了问题，你可以通过负载均衡器指向快速回滚到绿色环境。
- 理论上听起来很棒，但还是要注意一些细节：
*   当你切换到蓝色环境时，需要妥当处理未完成的业务和新的业务。如果你的数据库后端无法处理，会是一个比较麻烦的问题；
*   有可能会出现需要同时处理“微服务架构应用”和“传统架构应用”的情况，如果在蓝绿部署中协调不好这两者，还是有可能导致服务停止的；
*   需要提前考虑数据库与应用部署同步迁移/回滚的问题；
*   蓝绿部署需要有基础设施支持
*   在非隔离基础架构（VM、Docker等）上执行蓝绿部署，蓝色环境和绿色环境有被摧毁的风险
    
## A/B Testing
 
- A/B测试跟蓝绿部署完全是两码事。A/B测试是用来测试应用功能表现的方法，例如可用性、受欢迎程度、可见性等等。A/B测试通常用在应用的前端上，不过当然需要后端来支持。

![](https://pic2.zhimg.com/80/v2-316abccbc51197e653c8499de4ec9ffd_1440w.jpg)

- A/B测试与蓝绿部署的区别在于，A/B测试目的在于通过科学的实验设计、采样样本代表性、流量分割与小流量测试等方式来获得具有代表性的实验结论，并确信**该结论在推广到全部流量可信**；蓝绿部署的目的是**安全稳定地发布新版本**应用，并在必要时回滚。A/B测试和蓝绿部署可以同时使用。
 
## 灰度发布／金丝雀发布
 
- 灰度发布是在原有版本可用的情况下，同时部署一个新版本应用作为“金丝雀”（金丝雀对瓦斯极敏感，矿井工人携带金丝雀，以便及时发发现危险），测试新版本的性能和表现，以保障整体系统稳定的情况下，尽早发现、调整问题。

![](https://pic4.zhimg.com/80/v2-6cdaf80c724cb7d1321c4e07ebb2cef3_1440w.jpg)
 
灰度发布／金丝雀发布由以下几个步骤组成：
*   准备好部署各个阶段的工件，包括：构建工件，测试脚本，配置文件和部署清单文件。
*   从负载均衡列表中移除掉“金丝雀”服务器。
*   升级“金丝雀”应用（排掉原有流量并进行部署）。
*   对应用进行自动化测试。
*   将“金丝雀”服务器重新添加到负载均衡列表中（连通性和健康检查）。
*   如果“金丝雀”在线使用测试成功，升级剩余的其他服务器。（否则就回滚）

- 灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度。
- 灰度发布/金丝雀部署适用的场景：
  - 1、不停止老版本，额外搞一套新版本，不同版本应用共存。
  - 2、灰度发布中，常常按照用户设置路由权重，例如90%的用户维持使用老版本，10%的用户尝鲜新版本。
  - 3、经常与A/B测试一起使用，用于测试选择多种方案。AB test就是一种灰度发布方式，让一部分用户继续用A，一部分用户开始用B，如果用户对B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到B上面来。

## 滚动发布（rolling update）

- 滚动发布，一般是取出一个或者多个服务器停止服务，执行更新，并重新将其投入使用。周而复始，直到集群中所有的实例都更新成新版本。这种部署方式相对于蓝绿部署，更加节约资源——它不需要运行两个集群、两倍的实例数。我们可以部分部署，例如每次只取出集群的20%进行升级。
- 这种方式也有很多缺点，例如：
  - (1) 没有一个确定OK的环境。使用蓝绿部署，能够清晰地知道老版本是OK的，而使用滚动发布，无法确定。
  - (2) 修改了现有的环境。
  - (3) 回滚很困难。举个例子，在某一次发布中，我们需要更新100个实例，每次更新10个实例，每次部署需要5分钟。当滚动发布到第80个实例时，发现了问题，需要回滚。此时，脾气不好的程序猿很可能想掀桌子，因为回滚是一个痛苦，并且漫长的过程。
  - (4) 有的时候，我们还可能对系统进行动态伸缩，如果部署期间，系统自动扩容/缩容了，我们还需判断到底哪个节点使用的是哪个代码。尽管有一些自动化的运维工具，但是依然令人心惊胆战。
- 并不是说滚动发布不好，滚动发布也有它非常合适的场景。

## 红黑部署(Red-Black Deployment)

- 这是Netflix采用的部署手段，Netflix的主要基础设施是在AWS上，所以它利用AWS的特性，在部署新的版本时，通过AutoScaling Group用包含新版本应用的AMI的LaunchConfiguration创建新的服务器。测试不通过，找到问题原因后，直接干掉新生成的服务器以及Autoscaling Group就可以，测试通过，则将ELB指向新的服务器集群，然后销毁掉旧的服务器集群以及AutoScaling Group。
- 红黑部署的好处是服务始终在线，同时采用不可变部署的方式，也不像蓝绿部署一样得保持冗余的服务始终在线。
 
## 总结

- 对于云计算来说，以上三种策略都是可用的。不难想象，通过docker和kubernetes，我们可以很简单的实现蓝绿部署、A/B测试、灰度发布……比如好雨云，深度整合Docker和Kubernetes，提供给用户包括代码滚动上线、一键代码回滚等功能和特性在内的强大的CI/CD体验：）


# 应用

- 【2021-1-11】[策略算法工程师之路-因果分析.科学实验评估](https://zhuanlan.zhihu.com/p/161387546)
  - 1. A/B Test原理
  - 2. 实验分组划分
  - 3. 实验指标设计
  - 4. 实验效果评估
  - 5. 离线指标测算
  - 6. 实验结果分析

# k8s

【2021-12-1】[从零开始入门 K8s：详解 K8s 核心概念](https://www.infoq.cn/article/KNMAVdo3jXs3qPKqTZBw)
 
![从零开始入门 K8s：详解 K8s 核心概念](https://static001.infoq.cn/resource/image/1f/a7/1f5c9e99df79ea86ca5062fef22e21a7.png)
 
## 一、什么是 Kubernetes
 
[Kubernetes](https://baike.baidu.com/item/kubernetes/22864162?fr=aladdin)，从官方网站上可以看到，它是一个工业级的容器编排平台。Kubernetes 这个单词是希腊语，它的中文翻译是“舵手”或者“飞行员”。在一些常见的资料中也会看到“ks”这个词，也就是“K8s”，它是通过将 8 个字母“ubernete ”替换为“8”而导致的一个缩写
 
Kubernetes 为什么要用“舵手”来命名呢？大家可以看一下这张图：

![](https://static001.infoq.cn/resource/image/1f/a7/1f5c9e99df79ea86ca5062fef22e21a7.png)
 
这是一艘载着一堆集装箱的轮船，轮船在大海上运着集装箱奔波，把集装箱送到它们该去的地方。我们之前其实介绍过一个概念叫做 container，container 这个英文单词也有另外的一个意思就是“集装箱”。Kubernetes 也就借着这个寓意，希望成为运送集装箱的一个轮船，来帮助我们管理这些集装箱，也就是管理这些容器。
 
这个就是为什么会选用 Kubernetes 这个词来代表这个项目的原因。更具体一点地来说：Kubernetes 是一个自动化的容器编排平台，它负责应用的部署、应用的弹性以及应用的管理，这些都是基于容器的。
 
## 二、Kubernetes 有如下几个核心的功能：

*   服务的发现与负载的均衡；
*   容器的自动装箱，我们也会把它叫做 scheduling，就是“调度”，把一个容器放到一个集群的某一个机器上，Kubernetes 会帮助我们去做存储的编排，让存储的声明周期与容器的生命周期能有一个连接；
*   Kubernetes 会帮助我们去做自动化的容器的恢复。在一个集群中，经常会出现宿主机的问题或者说是 OS 的问题，导致容器本身的不可用，Kubernetes 会自动地对这些不可用的容器进行恢复；
*   Kubernetes 会帮助我们去做应用的自动发布与应用的回滚，以及与应用相关的配置密文的管理；
*   对于 job 类型任务，Kubernetes 可以去做批量的执行；
*   为了让这个集群、这个应用更富有弹性，Kubernetes 也支持水平的伸缩。

下面，我们希望以三个例子跟大家更切实地介绍一下 Kubernetes 的能力。
 
### 1、调度
 
Kubernetes 可以把用户提交的容器放到 Kubernetes 管理的集群的某一台节点上去。Kubernetes 的调度器是执行这项能力的组件，它会观察正在被调度的这个容器的大小、规格。
 
比如说它所需要的 CPU 以及它所需要的 memory，然后在集群中找一台相对比较空闲的机器来进行一次 placement，也就是一次放置的操作。在这个例子中，它可能会把红颜色的这个容器放置到第二个空闲的机器上，来完成一次调度的工作。

![](https://static001.infoq.cn/resource/image/72/c8/72ef4e91e8aa94108ee7186d64ae0fc8.png)

 
### 2、自动修复
 
Kubernetes 有一个节点健康检查的功能，它会监测这个集群中所有的宿主机，当宿主机本身出现故障，或者软件出现故障的时候，这个节点健康检查会自动对它进行发现。

下面 Kubernetes 会把运行在这些失败节点上的容器进行自动迁移，迁移到一个正在健康运行的宿主机上，来完成集群内容器的一个自动恢复。
 
![](https://static001.infoq.cn/resource/image/73/24/731d967b5dafa97e5506ec6205b98424.png)

![](https://static001.infoq.cn/resource/image/11/01/114253ad481b90ed1dfc93ec48b85901.png)
 
### 3、水平伸缩
 
Kubernetes 有业务负载检查的能力，它会监测业务上所承担的负载，如果这个业务本身的 CPU 利用率过高，或者响应时间过长，它可以对这个业务进行一次扩容。
 
比如说在下面的例子中，黄颜色的过度忙碌，Kubernetes 就可以把黄颜色负载从一份变为三份。接下来，它就可以通过负载均衡把原来打到第一个黄颜色上的负载平均分到三个黄颜色的负载上去，以此来提高响应的时间。

![](https://static001.infoq.cn/resource/image/a3/95/a33057f576155f405422b743ea052195.png)
 
![](https://static001.infoq.cn/resource/image/ed/26/ed28ccbbefddf9ade14ade35686ee026.png)

以上就是 Kubernetes 三个核心能力的简单介绍。

## 三、Kubernetes 的架构

Kubernetes 架构是一个比较典型的二层架构和 server-client 架构。Master 作为中央的管控节点，会去与 Node 进行一个连接。
 
所有 UI 的、clients、这些 user 侧的组件，只会和 Master 进行连接，把希望的状态或者想执行的命令下发给 Master，Master 会把这些命令或者状态下发给相应的节点，进行最终的执行。
 
![](https://static001.infoq.cn/resource/image/d5/96/d552582add20217effce933e998d9196.png)
 
Kubernetes 的 Master 包含四个主要的组件：API Server、Controller、Scheduler 以及 etcd。如下图所示：
 
![](https://static001.infoq.cn/resource/image/e9/49/e95c765b7ac2b6802b165e03acd40849.png)

*   API Server：顾名思义是用来处理 API 操作的，Kubernetes 中所有的组件都会和 API Server 进行连接，组件与组件之间一般不进行独立的连接，都依赖于 API Server 进行消息的传送；
*   Controller：是控制器，它用来完成对集群状态的一些管理。比如刚刚我们提到的两个例子之中，第一个自动对容器进行修复、第二个自动进行水平扩张，都是由 Kubernetes 中的 Controller 来进行完成的；
*   Scheduler：是调度器，“调度器”顾名思义就是完成调度的操作，就是我们刚才介绍的第一个例子中，把一个用户提交的 Container，依据它对 CPU、对 memory 请求大小，找一台合适的节点，进行放置；
*   etcd：是一个分布式的一个存储系统，API Server 中所需要的这些原信息都被放置在 etcd 中，etcd 本身是一个高可用系统，通过 etcd 保证整个 Kubernetes 的 Master 组件的高可用性。
  
我们刚刚提到的 API Server，它本身在部署结构上是一个可以水平扩展的一个部署组件；Controller 是一个可以进行热备的一个部署组件，它只有一个 active，它的调度器也是相应的，虽然只有一个 active，但是可以进行热备。
 
### Kubernetes 的架构：Node
 
Kubernetes 的 Node 是真正运行业务负载的，每个业务负载会以 Pod 的形式运行。等一下我会介绍一下 Pod 的概念。一个 Pod 中运行的一个或者多个容器，真正去运行这些 Pod 的组件的是叫做 kubelet，也就是 Node 上最为关键的组件，它通过 API Server 接收到所需要 Pod 运行的状态，然后提交到我们下面画的这个 Container Runtime 组件中。

![](https://static001.infoq.cn/resource/image/5c/f8/5c9fe50067821e9e86a74cae4cbdd9f8.png)

在 OS 上去创建容器所需要运行的环境，最终把容器或者 Pod 运行起来，也需要对存储跟网络进行管理。Kubernetes 并不会直接进行网络存储的操作，他们会靠 Storage Plugin 或者是网络的 Plugin 来进行操作。用户自己或者云厂商都会去写相应的 Storage Plugin 或者 Network Plugin，去完成存储操作或网络操作。

在 Kubernetes 自己的环境中，也会有 Kubernetes 的 Network，它是为了提供 Service network 来进行搭网组网的。（等一下我们也会去介绍“service”这个概念。）真正完成 service 组网的组件的是 Kube-proxy，它是利用了 iptable 的能力来进行组建 Kubernetes 的 Network，就是 cluster network，以上就是 Node 上面的四个组件。

Kubernetes 的 Node 并不会直接和 user 进行 interaction，它的 interaction 只会通过 Master。而 User 是通过 Master 向节点下发这些信息的。Kubernetes 每个 Node 上，都会运行我们刚才提到的这几个组件。

下面我们以一个例子再去看一下 Kubernetes 架构中的这些组件，是如何互相进行 interaction 的。

![](https://static001.infoq.cn/resource/image/04/9b/047e4723316d6424b26341de5007329b.png)
 
用户可以通过 UI 或者 CLI 提交一个 Pod 给 Kubernetes 进行部署，这个 Pod 请求首先会通过 CLI 或者 UI 提交给 Kubernetes API Server，下一步 API Server 会把这个信息写入到它的存储系统 etcd，之后 Scheduler 会通过 API Server 的 watch 或者叫做 notification 机制得到这个信息：有一个 Pod 需要被调度。
 
这个时候 Scheduler 会根据它的内存状态进行一次调度决策，在完成这次调度之后，它会向 API Server report 说：“OK！这个 Pod 需要被调度到某一个节点上。”
 
这个时候 API Server 接收到这次操作之后，会把这次的结果再次写到 etcd 中，然后 API Server 会通知相应的节点进行这次 Pod 真正的执行启动。相应节点的 kubelet 会得到这个通知，kubelet 就会去调 Container runtime 来真正去启动配置这个容器和这个容器的运行环境，去调度 Storage Plugin 来去配置存储，network Plugin 去配置网络。

这个例子我们可以看到：这些组件之间是如何相互沟通相互通信，协调来完成一次 Pod 的调度执行操作的。

## 四、Kubernetes 的核心概念与它的 API
 
### 核心概念
 
#### 第一个概念：Pod
 
Pod 是 Kubernetes 的一个最小调度以及资源单元。用户可以通过 Kubernetes 的 Pod API 生产一个 Pod，让 Kubernetes 对这个 Pod 进行调度，也就是把它放在某一个 Kubernetes 管理的节点上运行起来。一个 Pod 简单来说是对一组容器的抽象，它里面会包含一个或多个容器。

比如像下面的这幅图里面，它包含了两个容器，每个容器可以指定它所需要资源大小。比如说，一个核一个 G，或者说 0.5 个核，0.5 个 G。

当然在这个 Pod 中也可以包含一些其他所需要的资源：比如说我们所看到的 Volume 卷这个存储资源；比如说我们需要 100 个 GB 的存储或者 20GB 的另外一个存储。

![](https://static001.infoq.cn/resource/image/b2/9f/b246d174b3169a242ac5799bc962f69f.png)
 
在 Pod 里面，我们也可以去定义容器所需要运行的方式。比如说运行容器的 Command，以及运行容器的环境变量等等。Pod 这个抽象也给这些容器提供了一个共享的运行环境，它们会共享同一个网络环境，这些容器可以用 localhost 来进行直接的连接。而 Pod 与 Pod 之间，是互相有 isolation 隔离的。

#### 第二个概念：Volume
 
Volume 就是卷的概念，它是用来管理 Kubernetes 存储的，是用来声明在 Pod 中的容器可以访问文件目录的，一个卷可以被挂载在 Pod 中一个或者多个容器的指定路径下面。

而 Volume 本身是一个抽象的概念，一个 Volume 可以去支持多种的后端的存储。比如说 Kubernetes 的 Volume 就支持了很多存储插件，它可以支持本地的存储，可以支持分布式的存储，比如说像 ceph，GlusterFS ；它也可以支持云存储，比如说阿里云上的云盘、AWS 上的云盘、Google 上的云盘等等。

![](https://static001.infoq.cn/resource/image/54/5b/542cf5c317c5e567ba63a720802ae85b.png)

 
#### 第三个概念：Deployment
 
Deployment 是在 Pod 这个抽象上更为上层的一个抽象，它可以定义一组 Pod 的副本数目、以及这个 Pod 的版本。一般大家用 Deployment 这个抽象来做应用的真正的管理，而 Pod 是组成 Deployment 最小的单元。

Kubernetes 是通过 Controller，也就是我们刚才提到的控制器去维护 Deployment 中 Pod 的数目，它也会去帮助 Deployment 自动恢复失败的 Pod。

比如说我可以定义一个 Deployment，这个 Deployment 里面需要两个 Pod，当一个 Pod 失败的时候，控制器就会监测到，它重新把 Deployment 中的 Pod 数目从一个恢复到两个，通过再去新生成一个 Pod。通过控制器，我们也会帮助完成发布的策略。比如说进行滚动升级，进行重新生成的升级，或者进行版本的回滚。

![](https://static001.infoq.cn/resource/image/4e/e2/4ea8feaad09e871bbca804e7f61738e2.png)

#### 第四个概念：Service
 
Service 提供了一个或者多个 Pod 实例的稳定访问地址。
 
比如在上面的例子中，我们看到：一个 Deployment 可能有两个甚至更多个完全相同的 Pod。对于一个外部的用户来讲，访问哪个 Pod 其实都是一样的，所以它希望做一次负载均衡，在做负载均衡的同时，我只想访问某一个固定的 VIP，也就是 Virtual IP 地址，而不希望得知每一个具体的 Pod 的 IP 地址。
 
我们刚才提到，这个 pod 本身可能 terminal go（终止），如果一个 Pod 失败了，可能会换成另外一个新的。
 
对一个外部用户来讲，提供了多个具体的 Pod 地址，这个用户要不停地去更新 Pod 地址，当这个 Pod 再失败重启之后，我们希望有一个抽象，把所有 Pod 的访问能力抽象成一个第三方的一个 IP 地址，实现这个的 Kubernetes 的抽象就叫 Service。

实现 Service 有多种方式，Kubernetes 支持 Cluster IP，上面我们讲过的 kuber-proxy 的组网，它也支持 nodePort、 LoadBalancer 等其他的一些访问的能力。

![](https://static001.infoq.cn/resource/image/bb/4a/bbcd5a617d228099f69ddc987ca18f4a.png)
 

#### 第五个概念：Namespace
 
Namespace 是用来做一个集群内部的逻辑隔离的，它包括鉴权、资源管理等。Kubernetes 的每个资源，比如刚才讲的 Pod、Deployment、Service 都属于一个 Namespace，同一个 Namespace 中的资源需要命名的唯一性，不同的 Namespace 中的资源可以重名。

Namespace 一个用例，比如像在阿里巴巴，我们内部会有很多个 business units，在每一个 business units 之间，希望有一个视图上的隔离，并且在鉴权上也不一样，在 cuda 上面也不一样，我们就会用 Namespace 来去给每一个 BU 提供一个他所看到的这么一个看到的隔离的机制。

![](https://static001.infoq.cn/resource/image/a0/4d/a00719f494ae94a40be0be6012e5134d.png)
 
### Kubernetes 的 API
 
下面我们介绍一下 Kubernetes 的 API 的基础知识。从 high-level 上看，Kubernetes API 是由 \*\*HTTP+JSON \*\*组成的：用户访问的方式是 HTTP，访问的 API 中 content 的内容是 JSON 格式的。
 
Kubernetes 的 kubectl 也就是 command tool，Kubernetes UI，或者有时候用 curl，直接与 Kubernetes 进行沟通，都是使用 HTTP + JSON 这种形式。

下面有个例子：比如说，对于这个 Pod 类型的资源，它的 HTTP 访问的路径，就是 API，然后是 apiVesion: V1, 之后是相应的 Namespaces，以及 Pods 资源，最终是 Podname，也就是 Pod 的名字。

![](https://static001.infoq.cn/resource/image/23/2e/23921b341e482ad31ce28fc15269ad2e.png)

 
如果我们去提交一个 Pod，或者 get 一个 Pod 的时候，它的 content 内容都是用 JSON 或者是 YAML 表达的。上图中有个 yaml 的例子，在这个 yaml file 中，对 Pod 资源的描述也分为几个部分。
 
第一个部分，一般来讲会是 API 的 version。比如在这个例子中是 V1，它也会描述我在操作哪个资源；比如说我的 kind 如果是 pod，在 Metadata 中，就写上这个 Pod 的名字；比如说 nginx，我们也会给它打一些 label，我们等下会讲到 label 的概念。在 Metadata 中，有时候也会去写 annotation，也就是对资源的额外的一些用户层次的描述。

 
比较重要的一个部分叫做 Spec，Spec 也就是我们希望 Pod 达到的一个预期的状态。比如说它内部需要有哪些 container 被运行；比如说这里面有一个 nginx 的 container，它的 image 是什么？它暴露的 port 是什么？
 
当我们从 Kubernetes API 中去获取这个资源的时候，一般来讲在 Spec 下面会有一个项目叫 status，它表达了这个资源当前的状态；比如说一个 Pod 的状态可能是正在被调度、或者是已经 running、或者是已经被 terminates，就是被执行完毕了。
 
刚刚在 API 之中，我们讲了一个比较有意思的 metadata 叫做“label”，这个 label 可以是一组 KeyValuePair。
 
比如下图的第一个 pod 中，label 就可能是一个 color 等于 red，即它的颜色是红颜色。当然你也可以加其他 label，比如说 size: big 就是大小，定义为大的，它可以是一组 label。
 
这些 label 是可以被 selector，也就是选择器所查询的。这个能力实际上跟我们的 sql 类型的 select 语句是非常相似的，比如下图中的三个 Pod 资源中，我们就可以进行 select。name color 等于 red，就是它的颜色是红色的，我们也可以看到，只有两个被选中了，因为只有他们的 label 是红色的，另外一个 label 中写的 color 等于 yellow，也就是它的颜色是黄色，是不会被选中的。
 
![](https://static001.infoq.cn/resource/image/01/b7/01cd07a0428ef67b59b7c3f2148c0cb7.png)

 
通过 label，kubernetes 的 API 层就可以对这些资源进行一个筛选，那这些筛选也是 kubernetes 对资源的集合所表达默认的一种方式。
 
例如说，我们刚刚介绍的 Deployment，它可能是代表一组的 Pod，它是一组 Pod 的抽象，一组 Pod 就是通过 label selector 来表达的。当然我们刚才讲到说 service 对应的一组 Pod，就是一个 service 要对应一个或者多个的 Pod，来对它们进行统一的访问，这个描述也是通过 label selector 来进行 select 选取的一组 Pod。
 
所以可以看到 label 是一个非常核心的 kubernetes API 的概念，我们在接下来的课程中也会着重地去讲解和介绍 label 这个概念，以及如何更好地去使用它。


# Docker

Docker的三大核心概念：镜像、容器、仓库
- **镜像**：类似虚拟机的镜像、用俗话说就是安装文件。
- **容器**：类似一个轻量级的沙箱，容器是从镜像创建应用运行实例，可以将其启动、开始、停止、删除、而这些容器都是相互隔离、互不可见的。
- **仓库**：类似代码仓库，是Docker集中存放镜像文件的场所。


## docker安装

资料
- 【2020-03-26】[linux上安装Docker(非常简单的安装方法)](https://cloud.tencent.com/developer/article/1605163)
- 【2019-05-13】[linux安装docker](https://www.jianshu.com/p/2dae7b13ce2f)

centos下安装docker，前置条件：
- 64-bit 系统
- kernel 3.10+

```shell
# -------- 方法① ----------
curl -sSL https://get.daocloud.io/docker | sh # 一键安装
docker ps # 检测状态
systemctl start docker.service # 启动服务
#systemctl restart docker.service # 重启服务
sudo systemctl enable docker # 开机自启
# -------- 方法② ----------
# 检查内核
uname -r
# 更新yum
yum update
# 添加yum仓库
tee /etc/yum.repos.d/docker.repo <<-'EOF'
[dockerrepo]
name=Docker Repository
baseurl=https://yum.dockerproject.org/repo/main/centos/$releasever/
enabled=1
gpgcheck=1
gpgkey=https://yum.dockerproject.org/gpg
EOF
# 安装docker
yum install -y docker-engine
# 查看是否安装成功
docker version
# 启动docker
systemctl start docker.service
# 开机启动
sudo systemctl enable docker
# -------- 方法③ ---------- 阿里云镜像 ------
# 安装依赖包
sudo yum install -y yum-utils device-mapper-persistent-data lvm2 
# 设置阿里云镜像源
sudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 
# 安装 Docker-CE
sudo yum install docker-ce
# 开机自启
sudo systemctl enable docker 
# 启动docker服务  
sudo systemctl start docker
# 添加docker用户组（可选）
# 1. 建立 Docker 用户组
sudo groupadd docker
# 2.添加当前用户到 docker 组
sudo usermod -aG docker $USER
# 镜像加速配置
# 加速器地址 ：
# 阿里云控制台搜索容器镜像服务
# 进入容器镜像服务， 左侧最下方容器镜像服务中复制加速器地址
sudo mkdir -p /etc/docker
sudo tee /etc/docker/daemon.json <<-'EOF'
{
  "registry-mirrors": ["你的加速器地址"]
}
EOF
# 重启docker
sudo systemctl daemon-reload
sudo systemctl restart docker
```

[dockerhub](https://hub.docker.com/search?q=&type=image)镜像
- ![](https://upload-images.jianshu.io/upload_images/9494436-2a2035d70223703e.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)


```shell
# 下载镜像：docker pull <镜像名:tag>    如：下载centos镜像
sudo docker pull bitnami/tensorflow-serving # 安装TensorFlow serving
docker pull centos
docker pull sameersbn/redmine:latest
# 查看已下载镜像
docker images
# 删除容器
docker rm <容器名 or ID>
# 查看容器日志
docker logs -f <容器名 or ID>
# 查看正在运行的容器
docker ps
# 查看所有的容器，包括已经停止的。
docker ps -a 
# 删除所有容器
docker rm $(docker ps -a -q)
# 停止、启动、杀死指定容器
docker start <容器名 or ID> # 启动容器
docker stop <容器名 or ID> # 启动容器
docker kill <容器名 or ID> # 杀死容器
# 后台运行 docker run -d <Other Parameters>
docker run -d -p 127.0.0.1:33301:22 centos6-ssh
# 暴露端口： 一共有三种形式进行端口映射
docker -p ip:hostPort:containerPort # 映射指定地址的主机端口到容器端口
# 例如：docker -p 127.0.0.1:3306:3306 映射本机3306端口到容器的3306端口
docker -p ip::containerPort # 映射指定地址的任意可用端口到容器端口
# 例如：docker -p 127.0.0.1::3306 映射本机的随机可用端口到容器3306端口
docer -p hostPort:containerPort # 映射本机的指定端口到容器的指定端口
# 例如：docker -p 3306:3306 # 映射本机的3306端口到容器的3306端口
# 映射数据卷
docker -v /home/data:/opt/data # 这里/home/data 指的是宿主机的目录地址，后者则是容器的目录地址
```

## 构建docker镜像

构建Docker镜像有以下两种方法：
- 1：使用docker commit命令。
- 2：使用docker build命令和 Dockerfile 文件。
一般情况下并不推荐使用“docker commit”来构建镜像，而应该使用更灵活、更强大的Dockerfile来构建Docker镜像，这里就来说一下使用Dockerfile创建镜像，创建容器并运行的方法。

- 注意：源码文件和Dockerfile文件放到同一个目录下
  - Dockerfile
  - jdk-8u162-linux-x64.tar.gz

## docker GUI 管理

推荐使用 Portainer 作为容器的 GUI 管理方案。[官方地址](https://portainer.io/install.html)

```shell
# 安装
docker volume create portainer_data
docker run -d -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer
```

 IP:9000 即可进入容器管理页面
 - ![](https://upload-images.jianshu.io/upload_images/9494436-296c9fe77d4af513.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

## Docker命令

[docker常用命令精华](https://mp.weixin.qq.com/s/TZgd00oeBGUocPRQyP3v_A)


```shell
# 构建镜像（当前目录dockerfile）
#   -t 镜像名称及标签（name:tag），tag一般表示版本号，一次构建中可以设置多个tag
#   . 待构建的上下文环境目录
docker build -t myubuntu:v1 .
# 构建镜像：指定源dockerfile
docker build . -f ./build/fpm/Dockerfile  -t php:latest

# 查看生成的镜像
docker images
# 创建容器(命名为myubuntu_test)并运行命令（/bin/bash）, 映射到本地主机 127.0.0.1 的 8111 端口上
docker run -it -p 127.0.0.1:8111:80 --name myubuntu_test myubuntu:v8 /bin/bash
# 后台模式启动容器
docker run -p 127.0.0.1:8111:80 -d --name myubuntu_test myubuntu:v8
# 登录到容器中
docker run -it myubuntu_test /bin/bash
# 查看运行中的容器：
docker ps
# 查看所有容器：
docker ps -a

```


### 容器生命周期管理命令

- run：创建一个新的容器。
- start/stop/restart
  - docker start # 启动一个或多个已经被停止的容器。
  - docker stop # 停止一个运行中的容器。
  - docker restart # 重启容器。
- kill：杀掉一个运行中的容器。可选参数：
  - -s : 发送什么信号到容器，默认 KILL
- rm：删除一个或多个容器。
- create：创建一个新的容器但不启动它。
- exec：在运行的容器中执行命令。可选参数：
  - -d : 分离模式: 在后台运行
  - -i : 即使没有附加也保持STDIN 打开
  - -t : 分配一个伪终端
- pause/unpause
  - docker pause :暂停容器中所有的进程。
  - docker unpause :恢复容器中所有的进程。

```shell
# 使用docker镜像nginx:latest以后台模式启动一个容器, 并将容器命名为mynginx。  
docker run --name mynginx -d nginx:latest  
# 使用镜像 nginx:latest，以后台模式启动一个容器, 将容器的 80 端口映射到主机的 80 端口, 主机的目录 /data 映射到容器的 /data。  
docker run -p 80:80 -v /data:/data -d nginx:latest  
# 使用镜像nginx:latest以交互模式启动一个容器, 在容器内执行/bin/bash命令。  
docker run -it nginx:latest /bin/bash  
# 启动已被停止的容器mynginx  
docker start mynginx  
# 停止运行中的容器mynginx  
docker stop mynginx  
# 重启容器mynginx  
docker restart mynginx  

# 根据容器名字杀掉容器  
docker kill tomcat7  
# 根据容器ID杀掉容器  
docker kill 65d4a94f7a39  

# 强制删除容器 db01、db02：  
docker rm -f db01 db02  
# 删除容器 nginx01, 并删除容器挂载的数据卷：  
docker rm -v nginx01  
# 删除所有已经停止的容器：  
docker rm $(docker ps -a -q) 

# 使用docker镜像nginx:latest创建一个容器,并将容器命名为mynginx  
docker create --name mynginx nginx:latest     

# 在容器 mynginx 中以交互模式执行容器内 /root/nginx.sh 脚本  
docker exec -it mynginx /bin/sh /root/nginx.sh  
# 在容器 mynginx 中开启一个交互模式的终端  
docker exec -i -t  mynginx /bin/bash  
# 也可以通过 docker ps -a 命令查看已经在运行的容器，然后使用容器 ID 进入容器。  
docker ps -a   
docker exec -it 9df70f9a0714 /bin/bash  

# 暂停数据库容器db01提供服务。  
docker pause db01  
# 恢复数据库容器 db01 提供服务  
docker unpause db0  
```

### 容器操作命令

- ps：列出容器。可选参数：
  - -a : 显示所有的容器，包括未运行的。
  - -f : 根据条件过滤显示的内容。
  - –format : 指定返回值的模板文件。
  - -l : 显示最近创建的容器。
  - -n : 列出最近创建的n个容器。
  - –no-trunc : 不截断输出。
  - -q : 静默模式，只显示容器编号。
  - -s : 显示总的文件大小。
- 补充说明：
  - 容器的7种状态：created（已创建）、restarting（重启中）、running（运行中）、removing（迁移中）、paused（暂停）、exited（停止）、dead（死亡）。
- inspect：获取容器/镜像的元数据。可选参数：
  - -f : 指定返回值的模板文件。
  - -s : 显示总的文件大小。
  - –type : 为指定类型返回JSON。
- top：查看容器中运行的进程信息，支持 ps 命令参数。
- events：获取实时事件。参数说明：
  - -f ： 根据条件过滤事件；
  - –since ： 从指定的时间戳后显示所有事件；
  - –until ： 流水时间显示到指定的时间为止；
- logs：获取容器的日志。参数说明：
  - -f : 跟踪日志输出
  - –since : 显示某个开始时间的所有日志
  - -t : 显示时间戳
  - –tail : 仅列出最新N条容器日志
- export：将文件系统作为一个tar归档文件导出到STDOUT。参数说明：
  - -o : 将输入内容写到文件。
- port：列出指定的容器的端口映射。


```shell
# 列出所有在运行的容器信息。  
docker ps  
# 列出最近创建的5个容器信息。  
docker ps -n 5  
# 列出所有创建的容器ID。  
docker ps -a -q  
# 获取镜像mysql:5.7的元信息。  
docker inspect mysql:5.7  
# 获取正在运行的容器mymysql的 IP。  
docker inspect --format='\{\{range .NetworkSettings.Networks\}\}\{\{.IPAddress\}\}\{\{end\}\}' mymysql  

# 查看容器mymysql的进程信息。  
docker top mymysql  

# 查看所有运行容器的进程信息。  
for i in  `docker ps |grep Up|awk '{print $1}'`;do echo \ &&docker top $i; done  

# 显示docker 2016年7月1日后的所有事件。  
docker events  --since="1467302400"  

# 显示docker 镜像为mysql:5.6 2016年7月1日后的相关事件。  
docker events -f "image"="mysql:5.6" --since="1467302400"   
# 说明：如果指定的时间是到秒级的，需要将时间转成时间戳。如果时间为日期的话，可以直接使用，如–since=“2016-07-01”。

# 跟踪查看容器mynginx的日志输出。  
docker logs -f mynginx  
# 查看容器mynginx从2016年7月1日后的最新10条日志。  
docker logs --since="2016-07-01" --tail=10 mynginx  

# 将id为a404c6c174a2的容器按日期保存为tar文件。  
docker export -o mysql-`date +%Y%m%d`.tar a404c6c174a2  

ls mysql-`date +%Y%m%d`.tar  

# 查看容器mynginx的端口映射情况。  
docker port mymysql  
```

### 容器rootfs命令

- commit: 从容器创建一个新的镜像。参数说明：
  - -a : 提交的镜像作者；
  - -c : 使用Dockerfile指令来创建镜像；
  - -m : 提交时的说明文字；
  - -p : 在commit时，将容器暂停。
- cp: 用于容器与主机之间的数据拷贝。参数说明：
  - -L : 保持源目标中的链接
- diff: 检查容器里文件结构的更改。

```shell
# 将容器a404c6c174a2 保存为新的镜像,
# 并添加提交人信息和说明信息。  
docker commit -a "guodong" -m "my db" a404c6c174a2  mymysql:v1   

# 将主机/www/runoob目录拷贝到容器96f7f14e99ab的/www目录下。  
docker cp /www/runoob 96f7f14e99ab:/www/  
# 将主机/www/runoob目录拷贝到容器96f7f14e99ab中，目录重命名为www。  
docker cp /www/runoob 96f7f14e99ab:/www  
# 将容器96f7f14e99ab的/www目录拷贝到主机的/tmp目录中。  
docker cp  96f7f14e99ab:/www /tmp/  

# 查看容器mymysql的文件结构更改。  
docker diff mymysql  
```

### 镜像仓库命令

仓库命令
- login/logoutdocker 
- login : 登陆到一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hubdocker 
- logout :登出一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub参数说明：
- 登陆到Docker Hub  
  - docker login -u 用户名 -p 密码  
  - -u : 登陆的用户名
  - -p : 登陆的密码
- pull：从镜像仓库中拉取或者更新指定镜像。参数说明：
  - -a : 拉取所有 tagged 镜像
  - –disable-content-trust : 忽略镜像的校验,默认开启
- push：将本地的镜像上传到镜像仓库,要先登陆到镜像仓库。参数说明：
  - –disable-content-trust : 忽略镜像的校验,默认开启
- search：从Docker Hub查找镜像。参数说明：
  - –automated : 只列出 automated build类型的镜像；
  - –no-trunc : 显示完整的镜像描述；
  - -f \<过滤条件>: 列出指定条件的镜像。

```shell
# 登出Docker Hub  
docker logout  

# 从Docker Hub下载java最新版镜像。  
docker pull java  

# 从Docker Hub下载REPOSITORY为java的所有镜像。  
docker pull -a java  

# 上传本地镜像myapache:v1到镜像仓库中。  
docker push myapache:v1  

# 从 Docker Hub 查找所有镜像名包含 java，并且收藏数大于 10 的镜像  
docker search -f stars=10 java  
#NAME                  DESCRIPTION                           STARS   OFFICIAL   AUTOMATED  
#java                  Java is a concurrent, class-based...   1037    [OK]         
#anapsix/alpine-java   Oracle Java 8 (and 7) with GLIBC ...   115                [OK]  
#develar/java                                                 46                 [OK]  

# 每列参数说明：
# NAME: 镜像仓库源的名称
# DESCRIPTION: 镜像的描述
# OFFICIAL: 是否 docker 官方发布
# stars: 类似 Github 里面的 star，表示点赞、喜欢的意思
# AUTOMATED: 自动构建
```

### 本地镜像管理命令

- images:列出本地镜像。参数说明：
  - -a : 列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；
  - –digests : 显示镜像的摘要信息；
  - -f : 显示满足条件的镜像；
  - –format : 指定返回值的模板文件；
  - –no-trunc : 显示完整的镜像信息；
  - -q : 只显示镜像ID。
- rmi:删除本地一个或多个镜像。参数说明：
  - -f : 强制删除；
  - –no-prune : 不移除该镜像的过程镜像，默认移除；
- tag: 标记本地镜像，将其归入某一仓库。
- build: 用于使用 Dockerfile 创建镜像。参数说明：
  - –build-arg=[] : 设置镜像创建时的变量；
  - –cpu-shares : 设置 cpu 使用权重；
  - –cpu-period : 限制 CPU CFS周期；
  - –cpu-quota : 限制 CPU CFS配额；
  - –cpuset-cpus : 指定使用的CPU id；
  - –cpuset-mems : 指定使用的内存 id；
  - –disable-content-trust : 忽略校验，默认开启；
  - -f : 指定要使用的Dockerfile路径；
  - –force-rm : 设置镜像过程中删除中间容器；
  - –isolation : 使用容器隔离技术；
  - –label=[] : 设置镜像使用的元数据；
  - -m : 设置内存最大值；
  - –memory-swap : 设置Swap的最大值为内存+swap，"-1"表示不限swap；
  - –no-cache : 创建镜像的过程不使用缓存；
  - –pull : 尝试去更新镜像的新版本；
  - –quiet, -q : 安静模式，成功后只输出镜像 ID；
  - –rm : 设置镜像成功后删除中间容器；
  - –shm-size : 设置/dev/shm的大小，默认值是64M；
  - –ulimit : Ulimit配置。
  - –squash : 将 Dockerfile 中所有的操作压缩为一层。
  - –tag, -t: 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。
  - –network: 默认 default。在构建期间设置RUN指令的网络模式
- history: 查看指定镜像的创建历史。参数说明：
  - -H : 以可读的格式打印镜像大小和日期，默认为true；
  - –no-trunc : 显示完整的提交记录；
  - -q : 仅列出提交记录ID。
- save: 将指定镜像保存成 tar 归档文件。参数说明：
  - -o : 输出到的文件。
- load: 导入使用 docker save 命令导出的镜像。参数说明：
  - –input , -i : 指定导入的文件，代替 STDIN。
  - –quiet , -q : 精简输出信息。
- import: 从归档文件中创建镜像。参数说明：
  - -c : 应用docker 指令创建镜像；
  - -m : 提交时的说明文字；

```shell
# 查看本地镜像列表。  
docker images  
# 列出本地镜像中REPOSITORY为ubuntu的镜像列表。  
docker images  ubuntu  

# 强制删除本地镜像 guodong/ubuntu:v4。  
docker rmi -f guodong/ubuntu:v4  

# 将镜像ubuntu:15.10标记为 runoob/ubuntu:v3 镜像。  
docker tag ubuntu:15.10 runoob/ubuntu:v3  

# 使用当前目录的 Dockerfile 创建镜像，标签为 runoob/ubuntu:v1  
docker build -t runoob/ubuntu:v1 .   

# 使用URL github.com/creack/docker-firefox 的 Dockerfile 创建镜像  
docker build github.com/creack/docker-firefox  

# 通过 -f Dockerfile文件的位置 创建镜像  
docker build -f /path/to/a/Dockerfile .  

# 查看本地镜像 guodong/ubuntu:v3 的创建历史。  
docker history guodong/ubuntu:v3  

# 将镜像 runoob/ubuntu:v3 生成 my_ubuntu_v3.tar 文档  
docker save -o my_ubuntu_v3.tar runoob/ubuntu:v3  

# 导入镜像  
docker load --input fedora.tar  

# 从镜像归档文件my_ubuntu_v3.tar创建镜像，命名为runoob/ubuntu:v4  
docker import  my_ubuntu_v3.tar runoob/ubuntu:v4    
```


### 基础版本信息命令

- info: 显示 Docker 系统信息，包括镜像和容器数。
- version: 显示 Docker 版本信息。

```shell
# 查看docker系统信息。  
docker info  
# 版本信息
docker version  
```

## Dockerfile

Dockerfile文件

```Dockerfile
FROM ubuntu:18.10

# 注视单独成行
#Ingrediten:
#       jdk-8u162-linux-x64.tar.gz

RUN buildDeps='gcc libc6 make ssh net-tools iputils-ping git curl telnet vim yum' \
        && apt-get update       \
        && apt-get install -y $buildDeps        \
        && mkdir -p /opt/java/

COPY ./jdk-8u162-linux-x64.tar.gz  /opt/java/

RUN cd /opt/java/       \
        && tar -zxvf jdk-8u162-linux-x64.tar.gz

ENV JAVA_HOME=/opt/java/jdk1.8.0_162
ENV PATH=$JAVA_HOME/bin:$PATH
ENV CLASSPATH=.:$JAVA_HOME/bin/dt.jar:$JAVA_HOME/lib/tools.jar
```


# 结束


